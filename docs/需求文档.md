# 高性能内存缓存系统需求文档

## 1. 项目背景与问题分析

### 1.1 现状与挑战

在零信任访问控制业务场景中，随着企业用户规模的快速增长和访问控制策略的复杂化，开发团队面临着以下核心痛点：

---

#### 1.1.1 数据库性能瓶颈难以满足实时 ACL 计算要求

**问题描述：**

在零信任架构中，访问控制基于 ACL（Access Control List）策略进行实时计算：**主体（终端环境）→ 客体（内网应用）**。每次访问请求都需要根据主体的实时环境参数和客体应用的访问策略进行权限判定。传统基于磁盘的关系型数据库在高并发场景下存在严重的性能瓶颈：

- **响应延迟高**：数据库 I/O 延迟通常在 10-100ms 量级，而零信任网关需要在 50ms 内完成从请求接收、环境采集、ACL 计算到流量转发的全流程，数据库查询成为关键路径上的性能瓶颈
- **并发能力受限**：每次 ACL 计算需要查询主体环境信息、访问策略规则、历史行为等多个表，涉及复杂的多表关联查询，在高并发下数据库连接池快速耗尽
- **数据库负载压力**：某企业客户有 10,000+ 员工，每人每天平均访问 500 次内网应用，意味着每天 500 万次 ACL 计算，即使有 80% 的缓存命中率，仍有 100 万次查询落到数据库，导致 CPU 负载常年 >80%

**ACL 业务场景实例：**

**ACL 策略模型说明：**
- **主体（Subject）**：用户终端环境，包含操作系统类型、IP 地址、地理位置、访问时间、设备健康度等参数
- **客体（Object）**：被访问的内网应用（如 ERP 系统、OA 系统、代码仓库等）
- **访问控制策略**：基于主体和客体的匹配规则，决定允许或拒绝访问

**场景 1：终端环境实时参数查询**

- 用户尝试访问内网 OA 系统，网关需要实时获取终端环境参数（操作系统版本、IP 地理位置、设备健康度）
- 传统方案：从数据库查询终端环境表（terminal_env），耗时 50-150ms
- 业务要求：需要在 20ms 内完成环境参数查询和 ACL 计算，否则用户感知明显延迟
- 性能问题：每次访问都查询数据库，高峰期数据库成为瓶颈，用户访问 OA 系统需要等待 3-5 秒

**场景 2：动态 ACL 规则匹配**

- 每次访问请求需要匹配基于主体环境（如仅允许公司 IP、仅允许工作时间）和客体应用（如财务系统仅允许财务部员工）的动态 ACL 规则
- ACL 规则示例：
  ```
  允许 IF 终端操作系统 = Windows AND 终端IP在允许列表 AND 访问时间在工作时间
  允许 IF 终端地理位置 = 国内 AND 客体应用 != 机密系统 AND 终端健康度 = 高
  拒绝 IF 终端IP在黑名单 OR 终端健康度 = 低
  ```
- 传统方案：将所有 ACL 规则加载到应用内存，规则更新时需要重启所有网关实例；或者每次请求都查询数据库获取最新规则
- 业务要求：ACL 规则更新后 1 秒内全局生效，且查询延迟 <10ms
- 性能问题：查询数据库获取匹配规则耗时 50-200ms，无法满足实时性要求

**场景 3：主体环境变化实时检测**

- 终端环境参数会动态变化（如用户从公司移动到咖啡厅，IP 地址和地理位置发生变化），需要实时检测并调整访问权限
- 传统方案：每次访问都从数据库查询最新环境参数，数据库成为瓶颈；或者使用本地缓存，但环境变化后无法实时同步到所有网关实例
- 业务要求：环境变化后 5 秒内同步到所有实例，且查询延迟 <5ms
- 性能问题：本地缓存不一致导致某用户在环境变化后 10 分钟内仍能以旧环境参数访问应用，存在安全风险

**实际影响：**

- **用户体验差**：访问内网应用时需要等待 3-5 秒完成环境采集和 ACL 计算，员工抱怨系统响应慢，影响工作效率
- **安全风险**：由于性能压力，部分 ACL 计算被降级处理（如跳过终端健康度检查），增加了安全风险；某次审计发现，终端感染病毒的员工仍能访问机密系统，因为健康度检查被跳过
- **成本上升**：为了缓解性能问题，团队采购高性能数据库服务器（32 核 CPU、256GB 内存、NVMe SSD），硬件成本增加 50%，但性能提升有限
- **扩展困难**：业务增长到 50,000+ 用户时，即使采用读写分离、分库分表等优化手段，数据库仍成为瓶颈，无法线性扩展

---

#### 1.1.2 多实例本地缓存导致 ACL 数据不一致

**问题描述：**

为了缓解数据库压力，开发团队在各个网关实例中引入了本地内存缓存（如 Go 的 sync.Map、Java 的 Caffeine Cache）。虽然减少了数据库查询，但引入了新的问题：

- **数据一致性无法保证**：每个网关实例维护独立的缓存副本，终端环境参数、ACL 规则等数据更新时只能通知部分实例或依赖 TTL 过期，导致不同实例上的缓存数据不一致
- **缓存更新机制复杂**：采用 Redis Pub/Sub 通知缓存失效，但在网络波动或消息丢失时会导致缓存不一致；采用定时刷新则延迟高，且浪费资源
- **ACL 判定结果不一致**：同一个用户的同一个访问请求，路由到不同网关实例可能得到不同的 ACL 判定结果，导致安全漏洞

**ACL 业务场景实例：**

**场景 1：用户会话状态不一致**

- 用户在网关 A 完成身份认证，会话信息和 ACL 权限缓存在网关 A 的本地内存
- 用户下次访问请求被负载均衡到网关 B，网关 B 的本地缓存中没有会话信息，要求用户重新认证
- 用户投诉"频繁需要重新登录"，影响用户体验
- 业务影响：客服部门每月收到 200+ 投诉，用户满意度调查评分下降 15%

**场景 2：终端环境更新延迟**

- 安全运营人员在管理后台将某个终端的IP从"允许列表"移除（如员工离职，设备回收）
- 更新请求落到网关 A，网关 A 的缓存被标记失效，但网关 B、C、D 的缓存仍然保留旧数据
- 该终端用户通过网关 B 访问应用时，仍然以旧 IP 地址通过 ACL 检查，绕过了安全策略
- 安全事件：某离职员工在设备被回收后 20 分钟内仍能访问内部系统，查看敏感文件，就是因为本地缓存不一致导致

**场景 3：ACL 规则同步延迟**

- 安全团队更新 ACL 规则（如新增规则：拒绝所有来自境外的访问请求），紧急应对安全威胁
- 由于缓存更新机制依赖 Pub/Sub 消息，某网关实例未收到消息（网络抖动导致消息丢失）
- 旧规则在该实例上仍然生效，境外 IP 在接下来 15 分钟内仍然可以通过该网关访问应用，直到缓存 TTL 过期
- 安全事件：某次攻击中，攻击者利用 ACL 规则同步延迟问题，从境外 IP 访问了内部系统，窃取了数据

**场景 4：终端健康度评分不一致**

- 终端健康度评分需要综合多个参数（杀毒软件状态、系统补丁级别、磁盘加密状态等），实时计算并缓存
- 不同网关实例的本地缓存独立维护，导致同一终端在不同实例上的健康度评分可能不一致
- 业务影响：某终端在网关 A 上被评为"健康"，允许访问所有应用；但在网关 B 上被评为"不健康"，拒绝访问；用户感到困惑，投诉"系统不稳定"

**场景 5：访问限流计数不准确**

- 实现 API 访问限流（如每用户每分钟最多 100 次请求），需要统计请求次数
- 将计数器存储在本地缓存，不同网关实例的计数器各自独立，导致实际限制是"每用户每分钟每个实例最多 100 次"，而非全局限制
- 攻击者可以通过分散请求到不同实例来绕过限流，导致 DDoS 攻击防护失效
- 安全事件：某次攻击中，攻击者利用限流计数不准确问题，发送了 10 倍于限额的请求，导致服务不可用

**实际影响：**

- **安全漏洞**：缓存不一致导致的权限绕过、会话劫持等安全漏洞，在某次安全审计中被标记为"高危风险"，需要紧急修复
- **排查困难**：用户反馈"有时候能访问，有时候不能"，开发团队花费 2 周时间排查，最终定位到多实例缓存不一致问题
- **运维复杂**：为了缓解问题，运维团队制定了复杂的缓存管理流程（如定期清空所有实例缓存、紧急情况下手动重启所有实例），增加了运维负担
- **开发效率低**：业务开发团队需要关心缓存的分布式一致性，无法专注于业务逻辑，代码中充斥着缓存失效、重试、降级等逻辑，代码复杂度上升 40%

---

### 1.2 用户需求清单

基于以上痛点分析，从用户（业务开发团队、运维团队、安全团队）角度总结出以下需求：

#### 1.2.1 业务开发团队需求

| 需求 | 优先级 | 业务说明 |
|------|--------|----------|
| **微秒级响应速度** | P0 | ACL 计算需要查询终端环境参数和访问规则，总响应时间必须 <20ms，其中数据查询部分应 <1ms，否则用户感知明显延迟 |
| **丰富的数据组织方式** | P0 | 需要存储不同类型的数据：终端环境信息是键值对形式（设备ID → {操作系统, IP, 地理位置}），访问规则是列表形式，黑名单是集合形式，访问日志是时序列表形式 |
| **准确的数据更新保证** | P0 | 访问限流场景下，多个网关实例同时更新计数器时必须保证数据准确性，不能出现计数错误导致限流失效 |
| **自动数据清理** | P0 | 临时访问凭证、会话信息等数据有明确的生命周期（如 5 分钟过期），系统应自动清理过期数据，无需手动编写清理逻辑和定时任务 |
| **批量数据操作** | P1 | 批量查询终端信息、批量更新访问规则时，希望一次请求完成，减少网络往返次数，提升性能 |
| **多步操作的原子性** | P1 | 会话转移场景（删除旧会话、创建新会话、更新在线用户数）需要保证要么全部成功，要么全部失败，避免出现中间状态 |
| **简单易用的接口** | P1 | 提供 Go、Java、Python 等语言的客户端库，封装底层通信细节，开发人员只需关注业务逻辑 |

#### 1.2.2 运维团队需求

| 需求 | 优先级 | 业务说明 |
|------|--------|----------|
| **数据不丢失** | P0 | 系统重启或故障后，内存中的数据能够恢复，避免终端环境、访问规则等数据丢失，导致服务不可用 |
| **服务高可用** | P0 | 主节点故障时，从节点可以接管服务，避免服务中断，影响用户访问 |
| **内存使用可控** | P0 | 当内存使用达到上限时，系统能够自动清理旧数据，避免内存溢出导致系统崩溃 |
| **实时运行状态监控** | P1 | 能够查看内存使用情况、访问请求数、响应延迟、连接数等指标，及时发现性能瓶颈 |
| **在线配置调整** | P1 | 能够在线修改内存上限、清理策略等配置，无需重启服务，避免影响用户访问 |
| **性能问题定位** | P2 | 能够记录响应时间过长的操作，帮助定位性能瓶颈，优化系统性能 |
| **数据备份迁移** | P2 | 能够将数据导出为文件，用于数据备份、跨环境迁移（开发环境 → 测试环境 → 生产环境） |

#### 1.2.3 安全团队需求

| 需求 | 优先级 | 业务说明 |
|------|--------|----------|
| **全局数据一致性** | P0 | 所有网关实例访问到的数据必须一致，避免因数据不一致导致权限绕过（如某终端 IP 已被加入黑名单，但部分网关实例仍能通过） |
| **数据实时同步** | P0 | 访问规则更新、黑名单变更等操作，需要在 1 秒内同步到所有网关实例，满足实时安全策略要求 |
| **身份认证** | P1 | 访问缓存系统需要提供密码认证，防止未授权访问，避免数据泄露 |
| **敏感信息保护** | P1 | 敏感操作（如密码验证）不应在日志中记录，避免密码泄露 |
| **操作审计追溯** | P2 | 记录数据修改操作（如谁在什么时间修改了访问规则），用于安全审计和事后追溯 |

---

### 1.3 解决方案定位

基于以上需求，我们需要构建一个**高性能内存缓存系统**，其核心定位：

1. **极致性能**：基于内存存储，提供微秒级的读写响应（P99 <1ms），满足零信任架构的实时 ACL 计算要求
2. **全局一致性**：集中式存储，所有客户端访问同一份数据，避免多实例缓存不一致问题
3. **丰富数据结构**：支持字符串，字典，列表，集合等多种数据类型，满足终端环境参数存储、ACL 规则匹配、黑白名单管理等复杂场景
4. **自动过期管理**：精确的 TTL 控制（毫秒级精度），确保临时访问凭证、会话信息等敏感数据的生命周期安全
5. **原子操作保证**：分布式限流、计数器等场景的数据一致性
6. **可靠稳定**：提供持久化、主从复制等高可用机制，保障访问控制服务不中断

---

## 2. 系统需求定义

### 2.1 功能性需求

#### 2.1.1 基础数据操作（String类型）
**需求描述：** 提供基础键值存储能力

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| SET | SET key value [EX seconds \| PX milliseconds] | OK | O(1) | 值最大512MB |
| GET | GET key | 值或nil | O(1) | - |
| DEL | DEL key [key ...] | 删除的键数量 | O(N) | N为键数量 |
| EXISTS | EXISTS key [key ...] | 存在的键数量 | O(N) | - |
| EXPIRE | EXPIRE key seconds | 1=成功, 0=失败 | O(1) | 最大秒数: 2^63-1 |
| TTL | TTL key | 剩余秒数(-1=永不过期, -2=不存在) | O(1) | - |
| PEXPIRE | PEXPIRE key milliseconds | 1=成功, 0=失败 | O(1) | 最大毫秒数: 2^63-1 |
| PTTL | PTTL key | 剩余毫秒数 | O(1) | - |

**规格基线：**
- **键名长度限制**：最大512MB
- **键值大小限制**：最大512MB
- **键数量限制**：单实例最多2^32-1个键（约43亿）
- **过期时间精度**：毫秒级（PX/PEXPIRE命令）
- **内存对齐**：键值对存储使用SDS结构，带长度前缀，二进制安全
- **批量操作支持**：DEL、EXISTS支持多键操作，减少网络往返

**使用场景：**
- 设备信任评分缓存（设备ID -> 信任分数、风险等级）
- 用户策略缓存（用户ID + 设备ID -> 访问策略JSON）
- 威胁情报缓存（IP/域名 -> 威胁等级、情报来源）

#### 2.1.2 字符串类型增强功能
**需求描述：** 在基础键值对之上，提供字符串类型的增强操作

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| INCR | INCR key | 递增后的值 | O(1) | 值必须为整数，范围: [-(2^63), 2^63-1] |
| INCRBY | INCRBY key increment | 递增后的值 | O(1) | increment为64位有符号整数 |
| DECR | DECR key | 递减后的值 | O(1) | 值必须为整数 |
| DECRBY | DECRBY key decrement | 递减后的值 | O(1) | decrement为64位有符号整数 |
| APPEND | APPEND key value | 追加后的字符串长度 | O(1) | 若key不存在，等同于SET |
| STRLEN | STRLEN key | 字符串长度 | O(1) | - |
| GETRANGE | GETRANGE key start end | 子串 | O(1) | 支持负索引，-1表示最后一个字符 |
| MSET | MSET key1 value1 [key2 value2 ...] | OK | O(N) | N为键值对数量，原子操作 |
| MGET | MGET key1 [key2 ...] | 值列表 | O(N) | N为键数量 |

**规格基线：**
- **整数范围**：64位有符号整数 [-(2^63), 2^63-1]
- **原子性保证**：INCR系列命令为原子操作，无竞态条件
- **批量操作上限**：MSET/MGET建议单次不超过100个键
- **数值溢出处理**：超出范围返回错误，不会回绕

**使用场景：**
- 用户访问频率计数（用于风控限流，如每分钟限制100次请求）
- 分布式环境下的唯一请求ID生成（用于审计追踪）
- 设备异常行为计数（如连续认证失败次数）

#### 2.1.3 列表类型
**需求描述：** 提供有序、可重复的元素集合，支持双向操作

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| LPUSH | LPUSH key value [value ...] | 列表长度 | O(1) | 可插入多个值 |
| RPUSH | RPUSH key value [value ...] | 列表长度 | O(1) | 可插入多个值 |
| LPOP | LPOP key [count] | 弹出的元素列表 | O(1) | count可选，批量弹出 |
| RPOP | RPOP key [count] | 弹出的元素列表 | O(1) | count可选，批量弹出 |
| LLEN | LLEN key | 列表长度 | O(1) | - |
| LINDEX | LINDEX key index | 指定索引的元素 | O(N) | N为索引位置，支持负索引 |
| LRANGE | LRANGE key start stop | 元素列表 | O(S+N) | S为start偏移，N为范围长度 |
| LTRIM | LTRIM key start stop | OK | O(N) | N为被删除元素数量 |

**规格基线：**
- **元素数量限制**：单个列表最多2^32-1个元素（约43亿）
- **元素大小限制**：每个元素最大512MB
- **索引范围**：支持负索引，-1表示最后一个元素
- **底层实现**：双向链表

**使用场景：**
- 安全事件队列（IDS/IPS告警从左侧推入，SOC分析从右侧弹出）
- 用户访问轨迹时间线（最新访问记录在左侧，支持回溯分析）
- 审计日志缓冲（临时存储日志批量写入数据库）

#### 2.1.4 集合类型
**需求描述：** 提供无序、唯一的元素集合，支持集合运算

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| SADD | SADD key member [member ...] | 新增成员数量 | O(N) | N为成员数量，自动去重 |
| SREM | SREM key member [member ...] | 删除的成员数量 | O(N) | N为成员数量 |
| SISMEMBER | SISMEMBER key member | 1=存在, 0=不存在 | O(1) | - |
| SCARD | SCARD key | 集合成员数量 | O(1) | - |
| SMEMBERS | SMEMBERS key | 所有成员列表 | O(N) | N为集合大小 |
| SINTER | SINTER key [key ...] | 交集成员列表 | O(N*M) | N为最小集合大小，M为集合数量 |
| SUNION | SUNION key [key ...] | 并集成员列表 | O(N) | N为所有集合大小之和 |
| SDIFF | SDIFF key [key ...] | 差集成员列表 | O(N) | N为所有集合大小之和 |
| SRANDMEMBER | SRANDMEMBER key [count] | 随机成员列表 | O(N) | count可选，不删除成员 |
| SPOP | SPOP key [count] | 随机弹出的成员 | O(N) | count可选，删除成员 |

**规格基线：**
- **元素数量限制**：单个集合最多2^32-1个成员（约43亿）
- **元素大小限制**：每个成员最大512MB
- **集合运算上限**：建议SINTER/SUNION/SDIFF操作的集合数量不超过10个
- **底层实现**：哈希表（map）

**使用场景：**
- 黑名单管理（恶意IP集合、恶意设备ID集合）
- 用户权限集合（用户ID -> 拥有的权限标签集合）
- 威胁情报关联（攻击者IP集合 ∩ 受害者IP集合，找出共同IP）
- 角色继承（子角色权限集合 ⊆ 父角色权限集合）

#### 2.1.5 有序集合类型
**需求描述：** 提供有序、唯一的元素集合，每个元素关联分数

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| ZADD | ZADD key score member [score member ...] | 新增成员数量 | O(M*log(N)) | M为成员数量，N为集合大小 |
| ZREM | ZREM key member [member ...] | 删除的成员数量 | O(M*log(N)) | M为成员数量 |
| ZCARD | ZCARD key | 集合成员数量 | O(1) | - |
| ZSCORE | ZSCORE key member | 分数（nil=不存在） | O(1) | - |
| ZINCRBY | ZINCRBY key increment member | 新分数 | O(log(N)) | increment为双精度浮点数 |
| ZRANGE | ZRANGE key start stop [WITHSCORES] | 成员列表 | O(log(N)+M) | M为返回成员数量，支持负索引 |
| ZREVRANGE | ZREVRANGE key start stop [WITHSCORES] | 成员列表（降序） | O(log(N)+M) | M为返回成员数量 |
| ZRANGEBYSCORE | ZRANGEBYSCORE key min max [WITHSCORES] | 成员列表 | O(log(N)+M) | 支持-inf、+inf、(符号开区间 |
| ZCOUNT | ZCOUNT key min max | 分数范围内的成员数 | O(log(N)) | - |
| ZRANK | ZRANK key member | 排名（从0开始） | O(log(N)) | nil=不存在 |
| ZREVRANK | ZREVRANK key member | 降序排名 | O(log(N)) | nil=不存在 |

**规格基线：**
- **元素数量限制**：单个有序集合最多2^32-1个成员（约43亿）
- **分数范围**：双精度浮点数，范围 -17亿 < score < 17亿
- **元素大小限制**：每个成员最大512MB
- **底层实现**：slice + map 组合（切片保持排序，哈希表提供O(1)查找）

**使用场景：**
- 实时风险排行榜（用户风险分数排行，Top 100高风险用户）
- 设备信任评分排序（按信任分数倒序，快速筛选低信任设备）
- 时间窗口限流（使用时间戳作为分数，快速清理过期记录）
- 异常行为统计（按访问频率排序，识别异常用户）

#### 2.1.6 哈希类型
**需求描述：** 提供字段-值对的映射表，适合存储对象

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| HSET | HSET key field value | 1=新增, 0=更新 | O(1) | 单个字段 |
| HMSET | HMSET key field1 value1 [field2 value2 ...] | OK | O(N) | N为字段数量 |
| HGET | HGET key field | 值或nil | O(1) | - |
| HMGET | HMGET key field1 [field2 ...] | 值列表 | O(N) | N为字段数量 |
| HGETALL | HGETALL key | 所有字段和值 | O(N) | N为哈希表大小 |
| HDEL | HDEL key field [field ...] | 删除的字段数量 | O(N) | N为字段数量 |
| HEXISTS | HEXISTS key field | 1=存在, 0=不存在 | O(1) | - |
| HINCRBY | HINCRBY key field increment | 递增后的值 | O(1) | increment为64位有符号整数 |
| HLEN | HLEN key | 字段数量 | O(1) | - |
| HKEYS | HKEYS key | 所有字段名 | O(N) | N为哈希表大小 |
| HVALS | HVALS key | 所有值 | O(N) | N为哈希表大小 |
| HSETNX | HSETNX key field value | 1=成功, 0=失败 | O(1) | 仅当字段不存在时设置 |

**规格基线：**
- **字段数量限制**：单个哈希最多2^32-1个字段（约43亿）
- **字段名长度限制**：每个字段名最大512MB
- **字段值大小限制**：每个字段值最大512MB
- **底层实现**：哈希表（map）

**使用场景：**
- 设备属性存储（设备ID -> {类型, OS版本, 位置, 信任分数}）
- 用户会话信息（会话ID -> {用户ID, 登录时间, 设备指纹, IP}）
- 访问策略规则（策略ID -> {资源, 动作, 条件, 优先级}）
- 风控规则配置（规则ID -> {阈值, 时间窗口, 处置动作}）

#### 2.1.7 过期与淘汰策略
**需求描述：** 自动管理数据生命周期，防止内存无限增长

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| EXPIRE | EXPIRE key seconds | 1=成功, 0=失败 | O(1) | 覆盖已有过期时间 |
| PEXPIRE | PEXPIRE key milliseconds | 1=成功, 0=失败 | O(1) | 毫秒级精度 |
| EXPIREAT | EXPIREAT key timestamp | 1=成功, 0=失败 | O(1) | timestamp为Unix秒数 |
| PEXPIREAT | PEXPIREAT key timestamp-ms | 1=成功, 0=失败 | O(1) | timestamp-ms为Unix毫秒数 |
| TTL | TTL key | 剩余秒数 | O(1) | -2=不存在, -1=永不过期 |
| PTTL | PTTL key | 剩余毫秒数 | O(1) | -2=不存在, -1=永不过期 |
| PERSIST | PERSIST key | 1=成功, 0=失败 | O(1) | 移除过期时间 |

**规格基线：**
- **过期时间精度**：毫秒级（PEXPIRE、PEXPIREAT）
- **过期时间范围**：0 到 2^63-1（约2920亿年）
- **删除策略**：
  - **惰性删除**：访问键时检查过期，已过期则删除
  - **时间轮主动删除**：使用分层时间轮，10ms间隔，1024个桶，自动触发过期回调
- **内存淘汰策略**（maxmemory限制触发时）：
  - **noeviction**：不淘汰，写操作返回错误（默认）
  - **allkeys-lru**：淘汰所有键的LRU
  - **volatile-lru**：仅淘汰设置了TTL的键的LRU
  - **allkeys-lfu**：淘汰所有键的LFU
  - **volatile-lfu**：仅淘汰设置了TTL的键的LFU
  - **allkeys-random**：随机淘汰所有键
  - **volatile-random**：随机淘汰设置了TTL的键
  - **volatile-ttl**：淘汰即将过期的键

**使用场景：**
- 一次性凭证存储（MFA验证码、邮件链接，5分钟过期）
- 短期访问令牌（ZTNA临时访问令牌，1小时过期）
- 会话超时管理（用户30分钟无活动自动下线）
- 威胁情报时效性（临时封禁IP，24小时自动解封）

#### 2.1.8 事务功能
**需求描述：** 保证一组操作的原子性执行

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| MULTI | MULTI | OK | O(1) | 标记事务开始 |
| EXEC | EXEC | 命令返回值数组 | O(N) | N为事务中的命令数量 |
| DISCARD | DISCARD | OK | O(1) | 取消事务 |
| WATCH | WATCH key [key ...] | OK | O(1) | 乐观锁，监视键 |
| UNWATCH | UNWATCH | OK | O(1) | 取消所有监视 |

**规格基线：**
- **事务隔离级别**：EXEC执行期间，不执行其他客户端的命令
- **原子性保证**：事务中的命令按顺序执行，中间不会插入其他命令
- **错误处理**：
  - 入队时语法错误：EXEC返回nil，所有命令不执行
  - 执行时运行时错误：已执行的命令不回滚，后续命令继续执行
- **乐观锁机制**：
  - WATCH监视的键被其他客户端修改，EXEC执行失败
  - EXEC失败后需重新执行MULTI开始新事务
- **命令数量限制**：单个事务建议不超过100个命令

**使用场景：**
- 分布式限流（检查计数器、递增计数器、返回结果，原子执行）
- 设备信任评分更新（读取当前分数、计算新分数、写入，原子执行）
- 会话状态转移（删除旧会话、创建新会话、更新在线用户数，原子执行）
- 风控规则触发（检查条件、记录事件、更新黑名单，原子执行）

### 2.2 非功能性需求

#### 2.2.1 可靠性要求

**需求背景：**
作为内存缓存系统，数据存储在内存中，存在以下风险：
- 进程崩溃或重启导致数据全部丢失
- 单点故障导致服务不可用
- 硬件故障导致数据无法恢复

为保障生产环境的稳定运行，必须提供数据持久化和高可用机制。

**持久化能力：**
- **RDB快照**（推荐用于备份）：
  - 定时将内存数据全量保存到磁盘
  - 支持配置保存策略（如每5分钟至少有1次写入则保存）
  - 生成紧凑的压缩文件，适合备份和恢复
- **AOF日志**（推荐用于数据安全）：
  - 记录每个写操作命令到日志文件
  - 支持多种同步策略（每秒同步、每个命令同步）
  - 重启时重放日志恢复数据
  - 支持AOF重写，压缩日志文件

**高可用能力：**
- **主从复制**：
  - 主节点处理写操作，从节点复制数据
  - 从节点可处理读操作，分担主节点压力
  - 支持全量同步（SYNC）和增量同步（PSYNC）
  - 支持复制积压缓冲区（backlog）用于部分同步

**数据恢复能力：**
- 系统故障重启后可从持久化文件恢复数据
- 支持将快照文件传输到其他服务器进行数据迁移
- AOF日志记录所有写操作，可用于审计和追溯

#### 2.2.2 性能要求

**响应时间指标：**

| 操作类型 | P50 | P95 | P99 | P99.9 | 测试条件 |
|---------|-----|-----|-----|-------|---------|
| GET/SET | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端, 值大小1KB |
| INCR/DECR | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端 |
| HGET/HSET | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端, 哈希10个字段 |
| LPUSH/RPUSH | < 100μs | < 1ms | < 2ms | < 10ms | 列表长度<1000 |
| ZADD/ZRANGE | < 200μs | < 1ms | < 3ms | < 15ms | 有序集合<1万成员 |
| MGET(100键) | < 1ms | < 5ms | < 10ms | < 50ms | 批量获取100个键 |

**吞吐量指标：**

| 测试场景 | QPS目标 | 测试工具 | 测试参数 |
|---------|---------|---------|---------|
| GET/SET (50并发) | ≥ 100,000 | redis-benchmark | 单键, 值大小1KB |
| SET/GET混合 (100并发) | ≥ 80,000 | redis-benchmark | 读写比1:1 |
| MGET批量 (50并发) | ≥ 50,000 | 自定义脚本 | 每次获取100个键 |
| Pipeline (50并发) | ≥ 150,000 | 自定义脚本 | 每个Pipeline 50个命令 |

**并发能力指标：**
- **最大并发连接数**：≥ 10,000个同时连接的客户端
- **连接建立速率**：≥ 5,000个连接/秒
- **内存占用**：每个连接占用 < 10KB内存

**内存使用效率：**
- **内存碎片率**：正常范围1.0~1.5，超过1.5需告警
- **最大内存限制**：支持配置maxmemory，超出后触发淘汰策略
- **键空间压缩**：小对象（< 64字节）使用特殊编码，节省内存

**网络性能：**
- **TCP延迟**：同城机房 < 0.5ms，跨地域 < 50ms
- **带宽利用率**：千兆网卡满载时吞吐量 ≥ 800Mbps
- **大值传输**：支持最大512MB的单值传输，传输速率 ≥ 100MB/s

#### 2.2.3 可用性要求

| 可用性指标 | 目标值 | 测量方法 |
|-----------|--------|---------|
| 服务可用性（SLA） | ≥ 99.9% | (总时间-故障时间)/总时间 |
| 节点重启时间 | < 30秒 | 带持久化恢复的单节点重启 |
| 数据丢失窗口 | < 1秒 | AOF每秒同步模式下最多丢失数据量 |
| 主从复制延迟 | < 1秒 | 主节点写入到从节点同步完成的时间差 |

**故障场景应对：**
- **主节点崩溃**：从节点可提升为主节点（手动配置）
- **网络分区**：需要手动处理分区恢复
- **从节点故障**：不影响主节点服务，自动重新同步
- **磁盘满**：拒绝写入操作并触发告警，不崩溃

#### 2.2.4 扩展性要求

| 扩展类型 | 指标 | 说明 |
|---------|------|------|
| 垂直扩展 | 支持多核CPU | 充分利用16核、32核服务器 |
| 内存扩展 | 单实例最大支持TB级内存 | 受限于硬件配置 |

#### 2.2.5 兼容性要求

**协议兼容：**
- **RESP协议（RESP2/RESP3）**：文本协议，简单易解析
- **Telnet友好**：支持直接使用Telnet/Netcat进行操作
- **批量操作**：支持Pipeline模式，减少网络往返

**客户端支持：**
| 语言 | 官方/推荐客户端 | 特性 |
|------|----------------|------|
| Go | go-redis | 连接池、Pipeline、集群支持 |
| Java | lettuce/Jedis | 异步、响应式、集群支持 |
| Python | redis-py | 连接池、事务、Pub/Sub |
| C/C++ | hiredis | 高性能、异步支持 |

**平台兼容：**
- **操作系统**：Linux (推荐)、macOS、Windows
- **CPU架构**：x86_64、ARM64
- **编译器**：GCC 4.9+、Clang 3.4+、MSVC 2015+

#### 2.2.6 可维护性要求

**监控指标：**

| 监控类别 | 指标名称 | 告警阈值 | 说明 |
|---------|---------|---------|------|
| 性能 | QPS | > 80,000 | 接近性能上限 |
| 性能 | 延迟P99 | > 10ms | 性能下降 |
| 性能 | 慢查询数 | > 10/分钟 | 执行时间>10ms的查询 |
| 内存 | 内存使用率 | > 80% | 接近maxmemory限制 |
| 内存 | 内存碎片率 | > 1.5 | 需要内存整理 |
| 内存 | 键数量 | > 1000万 | 键空间过大 |
| 连接 | 客户端连接数 | > 8000 | 接近连接上限 |
| 复制 | 主从延迟 | > 5秒 | 复制延迟过高 |
| 复制 | 复制积压缓冲区 | < 1MB | 可能导致部分同步失败 |
| 持久化 | RDB保存失败 | 连续3次 | 持久化异常 |

**运维工具：**
- **命令行客户端**：支持交互式操作、批量命令执行
- **数据导入导出**：
  - RDB文件：全量数据导入导出
- **调试工具**：
  - MONITOR：实时监控所有命令（生产环境慎用）
  - SLOWLOG：慢查询日志，记录执行时间超过阈值的命令
  - INFO：查看服务器状态和统计信息

#### 2.2.7 安全性要求

**访问控制：**
| 安全特性 | 说明 | 配置示例 |
|---------|------|---------|
| 密码认证 | 客户端连接后需AUTH命令验证 | requirepass yourpassword |

**数据安全：**
- **数据脱敏**：敏感命令（如AUTH）不在日志中记录

**安全基线：**
- 默认绑定127.0.0.1，仅本地访问
- 生产环境必须设置密码（至少16字符）

---

## 3. 系统架构设计要求

### 3.1 核心架构原则
1. **内存优先**：所有数据存储在内存，磁盘仅用于持久化
2. **单线程模型**（推荐）：避免锁竞争，简化并发控制
3. **I/O多路复用**：使用epoll/kqueue等机制处理并发连接
4. **事件驱动**：基于事件循环的异步处理模型

### 3.2 关键设计决策
- **数据结构实现**：
  - 使用Go原生数据结构（map、slice、双向链表）
  - 分片并发字典减少锁竞争
- **内存管理**：
  - 支持设置最大内存限制，防止OOM
  - 提供内存使用统计和碎片率监控
- **网络协议**：
  - RESP2协议
  - 支持管道（Pipeline）批量发送命令
- **TTL管理**：
  - 分层时间轮实现，10ms间隔，1024个桶
  - 惰性删除 + 主动删除相结合

---

## 4. 验收标准

### 4.1 功能验收
- [ ] 支持所有基础数据类型（String、List、Set、Hash、ZSet）
- [ ] 支持键的过期设置和自动淘汰
- [ ] 支持事务的原子性执行

### 4.2 可靠性验收
- [ ] 支持RDB和AOF两种持久化方式
- [ ] 支持主从复制和数据同步
- [ ] 进程崩溃后可从持久化文件恢复数据

### 4.3 性能验收
- [ ] 单实例QPS > 10万（SET/GET操作）
- [ ] P99响应时间 < 1毫秒
- [ ] 支持1万并发连接

### 4.4 稳定性验收
- [ ] 7x24小时稳定运行
- [ ] 内存使用可控（不超过maxmemory限制）

---

## 5. 附加说明

### 5.1 需求优先级
- **P0（必须有）**：基础数据类型、过期策略、持久化、主从复制
- **P1（重要）**：事务、AOF重写
- **P2（可选）**：哨兵高可用、集群模式

### 5.2 技术选型建议
- **编程语言**：Go（开发效率和性能平衡）
- **网络模型**：I/O多路复用（epoll/kqueue）
- **并发模型**：单线程事件循环 + 分片锁

### 5.3 演进路线
1. **第一阶段（已完成）**：实现基础的单机KV存储（String、Hash）
2. **第二阶段（已完成）**：完善数据类型（List、Set、ZSet）和过期机制
3. **第三阶段（已完成）**：增加事务功能和持久化机制
4. **第四阶段（已完成）**：实现主从复制
5. **第五阶段（待实现）**：实现哨兵高可用
6. **第六阶段（待实现）**：实现集群模式（水平扩展）

---

## 6. 总结

本需求文档从实际业务痛点出发，定义了一个高性能内存缓存系统的核心需求。该系统旨在解决：

1. **性能瓶颈**：通过内存存储和高效数据结构，提供微秒级响应
2. **业务多样性**：丰富的数据类型支持复杂业务场景
3. **分布式协作**：提供共享存储，支持分布式锁、会话共享等
4. **开发效率**：简化缓存管理，降低代码复杂度

通过实现上述需求，该系统将成为现代应用架构中不可或缺的基础设施。
