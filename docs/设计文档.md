# GoCache 高性能内存缓存系统设计文档

## 1. 介绍

### 1.1. 目的

GoCache 是一个用 Go 语言实现的高性能内存缓存系统,旨在解决现代互联网应用架构中的数据访问性能瓶颈、动态访问控制、复杂数据结构支持以及安全敏感数据生命周期管理等核心痛点。

本系统提供极致性能的微秒级读写响应、丰富的数据结构、精确的过期时间控制、原子操作保证以及可靠的持久化机制,满足零信任架构下的实时验证需求、风控系统的复杂查询需求以及安全数据的生命周期管理需求。

本设计文档描述 GoCache 的整体架构设计、核心模块实现、对外接口以及关键技术方案,为开发人员提供详细的技术实现指导。

### 1.2. 定义和缩写

| 术语/缩写 | 定义/解释 |
|----------|----------|
| RESP | REdis Serialization Protocol,Redis序列化协议 |
| AOF | Append Only File,追加文件持久化方式 |
| RDB | Database Binary,二进制文件快照持久化方式 |
| TTL | Time To Live,数据生存时间 |
| SDS | Simple Dynamic String,简单动态字符串 |
| LRU | Least Recently Used,最近最少使用淘汰算法 |
| LFU | Least Frequently Used,最不经常使用淘汰算法 |
| ZIPLIST | 压缩列表,小数据量时的内存优化编码 |
| SKIPLIST | 跳表,有序集合底层实现 |
| QUICKLIST | 快速列表,列表底层实现 |
| MFA | Multi-Factor Authentication,多因素认证 |
| ZTNA | Zero Trust Network Access,零信任网络访问 |
| ACL | Access Control List,访问控制列表 |

### 1.3. 参考和引用

- 需求文档:《高性能内存缓存系统需求文档》
- RESP 协议规范:参考行业标准协议
- 数据结构算法:跳表、哈希表、压缩列表等经典算法
- Go 并发编程:Go 语言并发模型最佳实践
- 持久化技术:AOF、RDB、混合持久化方案

---

# 2. 设计任务书

### 2.1 需求跟踪

|编号|需求点名称|需求点说明/验收条件|自检|
|---|---|---|---|
|1|基础数据操作|1. 支持String类型的SET/GET/DEL/EXISTS/TTL等基础命令;<br />2. 键值最大512MB;<br />3. 键数量支持2^32-1个;<br />4. 毫秒级过期时间精度|见3.1, 6.2|
|2|字符串增强功能|1. 支持INCR/INCRBY/DECR/DECRBY等原子操作;<br />2. 支持64位有符号整数范围;<br />3. 支持MSET/MGET批量操作;<br />4. 支持INCRBYFLOAT浮点数递增|见3.1, 6.3|
|3|列表类型|1. 支持LPUSH/RPUSH/LPOP/RPOP双向操作;<br />2. 支持LRANGE范围查询;<br />3. 支持BLPOP/BRPOP阻塞操作;<br />4. 列表元素最多2^32-1个|见3.1, 6.4|
|4|集合类型|1. 支持SADD/SREM/SISMEMBER等基本操作;<br />2. 支持SINTER/SUNION/SDIFF集合运算;<br />3. 自动去重;<br />4. 成员最多2^32-1个|见3.1, 6.5|
|5|有序集合类型|1. 支持ZADD/ZREM/ZRANGE等操作;<br />2. 支持ZRANGEBYSCORE范围查询;<br />3. 支持ZINCRBY分数递增;<br />4. 分数范围为双精度浮点数|见3.1, 6.6|
|6|哈希类型|1. 支持HSET/HGET/HMGET/HGETALL等操作;<br />2. 支持HINCRBY原子递增;<br />3. 字段数量最多2^32-1个;<br />4. 适合存储对象|见3.1, 6.7|
|7|过期与淘汰策略|1. 支持EXPIRE/PEXPIRE/TTL/PTTL命令;<br />2. 支持惰性删除和定期删除;<br />3. 支持8种内存淘汰策略;<br />4. 毫秒级精度|见3.1, 6.8|
|8|事务功能|1. 支持MULTI/EXEC/DISCARD事务;<br />2. 支持WATCH/UNWATCH乐观锁;<br />3. 保证原子性和隔离性;<br />4. 单个事务建议不超过100个命令|见3.1, 6.9|
|9|持久化能力|1. 支持RDB快照持久化;<br />2. 支持AOF日志持久化;<br />3. 支持混合持久化;<br />4. 支持数据恢复|见4.2, 6.10|
|10|高可用能力|1. 支持主从复制;<br />2. 支持增量同步;<br />3. 支持哨兵机制自动故障转移;<br />4. 主从切换时间<10秒|见4.3, 6.11|
|11|性能要求|1. GET/SET操作P99<1ms;<br />2. 单实例QPS≥100,000;<br />3. 支持10,000并发连接;<br />4. 每个连接内存占用<10KB|见2.2, 6.1|
|12|安全性要求|1. 支持密码认证;<br />2. 支持IP白名单;<br />3. 支持命令重命名和禁用;<br />4. 支持访问审计|见4.5.9, 6.12|

### 2.2 模块整体目标

|编号|目标项概述|对应的评审标准|自检|
|---|---|---|---|
|1|性能|QPS: GET/SET ≥ 100,000 (P99 < 1ms)<br>并发连接数: ≥ 10,000<br>新建连接速度: ≥ 5,000个/秒|通过|
|2|资源开销|内存: 初始约100MB,根据数据量动态分配<br>磁盘: 混合持久化约为数据量的1.1倍|通过|
|3|可靠性要求|数据持久化: AOF每秒同步模式下最多丢失1秒数据<br>主从切换: < 10秒<br>进程恢复: 可从持久化文件恢复数据|通过|
|4|兼容性|协议: 完全兼容RESP协议<br>客户端: 现有RESP客户端可直接连接|通过|
|5|可扩展性|命令: 支持动态添加命令<br>数据结构: 支持扩展新数据类型<br>持久化: 策略可配置|通过|
|6|安全性|认证: 支持AUTH密码认证<br>命令控制: 支持命令白名单/黑名单<br>IP限制: 支持IP白名单|通过|
|7|其他|监控: 慢查询日志、INFO状态查询<br>配置: 支持CONFIG热加载|通过|

### 2.3 流程要求

|该文档是否需要外部评审?|是|按设计流程要求|
|---|---|---|
|**审核人签名**|**XXX**|**时间:**|

---

# 3. 对外接口

### 3.1 API接口

#### 网络协议接口

|引用规范的名称|应用模块|代码实现|备注|
|---|---|---|---|
|RESP Protocol|TCP Server|protocol/parser|完全兼容RESP协议,支持TCP连接|

#### 核心命令接口

##### 基础数据操作命令

|名称|SET|---|---|---|
|---|---|---|---|---|
|**功能**|**设置键值对**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|键名,最大512MB|
|||value|string|in|键值,最大512MB|
|||NX|flag|in|可选:仅当键不存在时设置|
|||XX|flag|in|可选:仅当键已存在时设置|
|||EX|seconds|int|in|可选:设置过期时间(秒)|
|||PX|milliseconds|int|in|可选:设置过期时间(毫秒)|
|**返回值**|"OK"(成功)或nil(失败)|---|---|---|

|名称|GET|---|---|---|
|---|---|---|---|---|
|**功能**|**获取键值**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|键名|
|**返回值**|value值(存在)或nil(不存在)|---|---|---|

|名称|DEL|---|---|---|
|---|---|---|---|---|
|**功能**|**删除键**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key1, key2, ...|string|in|一个或多个键名|
|**返回值**|删除的键数量(int)|---|---|---|

|名称|EXPIRE|---|---|---|
|---|---|---|---|---|
|**功能**|**设置过期时间(秒)**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|键名|
|||seconds|int|in|过期时间(秒)|
|**返回值**|1(成功)或0(失败)|---|---|---|

|名称|TTL|---|---|---|
|---|---|---|---|---|
|**功能**|**获取剩余生存时间**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|键名|
|**返回值**|剩余秒数(-1=永不过期,-2=不存在)|---|---|---|

##### 字符串增强命令

|名称|INCR|---|---|---|
|---|---|---|---|---|
|**功能**|**原子递增**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|键名(值必须为整数)|
|**返回值**|递增后的值|---|---|---|

|名称|MGET|---|---|---|
|---|---|---|---|---|
|**功能**|**批量获取键值**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key1, key2, ...|string|in|一个或多个键名|
|**返回值**|值列表(不存在的键返回nil)|---|---|---|

##### 列表命令

|名称|LPUSH|---|---|---|
|---|---|---|---|---|
|**功能**|**列表左侧插入**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|列表键名|
|||value1, value2, ...|string|in|一个或多个值|
|**返回值**|插入后的列表长度|---|---|---|

|名称|LRANGE|---|---|---|
|---|---|---|---|---|
|**功能**|**获取列表范围元素**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|列表键名|
|||start|int|in|起始索引(支持负索引)|
|||stop|int|in|结束索引(支持负索引)|
|**返回值**|元素列表|---|---|---|

##### 集合命令

|名称|SADD|---|---|---|
|---|---|---|---|---|
|**功能**|**集合添加成员**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|集合键名|
|||member1, member2, ...|string|in|一个或多个成员|
|**返回值**|新增成员数量|---|---|---|

|名称|SINTER|---|---|---|
|---|---|---|---|---|
|**功能**|**计算集合交集**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key1, key2, ...|string|in|一个或多个集合键名|
|**返回值**|交集成员列表|---|---|---|

##### 有序集合命令

|名称|ZADD|---|---|---|
|---|---|---|---|---|
|**功能**|**有序集合添加成员**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|有序集合键名|
|||score1|float|in|第一个成员的分数|
|||member1|string|in|第一个成员|
|||...|...|...|可添加多个成员|
|**返回值**|新增成员数量|---|---|---|

|名称|ZRANGE|---|---|---|
|---|---|---|---|---|
|**功能**|**获取有序集合范围成员**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|有序集合键名|
|||start|int|in|起始索引(支持负索引)|
|||stop|int|in|结束索引(支持负索引)|
|||WITHSCORES|flag|in|可选:同时返回分数|
|**返回值**|成员列表(带分数如果指定)|---|---|---|

##### 哈希命令

|名称|HSET|---|---|---|
|---|---|---|---|---|
|**功能**|**哈希字段设置**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|哈希键名|
|||field|string|in|字段名|
|||value|string|in|字段值|
|**返回值**|1(新增)或0(更新)|---|---|---|

|名称|HGET|---|---|---|
|---|---|---|---|---|
|**功能**|**获取哈希字段值**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|哈希键名|
|||field|string|in|字段名|
|**返回值**|字段值(存在)或nil(不存在)|---|---|---|

|名称|HGETALL|---|---|---|
|---|---|---|---|---|
|**功能**|**获取哈希所有字段和值**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key|string|in|哈希键名|
|**返回值**|字段和值交错列表(field1, value1, field2, value2, ...)|---|---|---|

##### 事务命令

|名称|MULTI|---|---|---|
|---|---|---|---|---|
|**功能**|**标记事务开始**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|-|-|-|无参数|
|**返回值**|"OK"|---|---|---|

|名称|EXEC|---|---|---|
|---|---|---|---|---|
|**功能**|**执行事务**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|-|-|-|无参数|
|**返回值**|事务中命令的返回值数组,失败返回nil|---|---|---|

|名称|WATCH|---|---|---|
|---|---|---|---|---|
|**功能**|**监视键(乐观锁)**|---|---|---|
||参数名|类型|方向|说明|
||**参数**|key1, key2, ...|string|in|一个或多个键名|
|**返回值**|"OK"|---|---|---|

### 3.2. 消息接口

#### 主从复制内部消息

|名称|replication.sync|---|
|---|---|---|
|**说明**|**从节点向主节点发起同步请求**|---|
|**字段名**|**类型**|说明 |
|replicaId|string|从节点唯一标识|
|offset|int64|复制偏移量|
|dbIndex|int|数据库索引|

|名称|replication.bulk|---|
|---|---|---|
|**说明**|**主节点向从节点批量传输数据**|---|
|**字段名**|**类型**|说明 |
|data|[]byte|RDB格式数据或AOF命令数据|
|dbIndex|int|数据库索引|

---

# 4. 概要说明

### 4.1. 背景描述

#### 4.1.1. 工作原理

GoCache 是一个基于内存的高性能键值存储系统,其核心工作原理如下:

1. **数据存储模型**:采用 key-value 存储模型,支持多种数据结构(String、List、Hash、Set、Sorted Set)

2. **并发控制**:使用分片锁(Sharded Lock)机制实现高并发访问,将数据按哈希分散到多个分片,每个分片独立加锁,大幅降低锁竞争

3. **持久化机制**:
   - **AOF(追加文件)**:记录每个写操作命令到日志文件,支持每秒同步、每个命令同步等多种策略
   - **RDB(快照)**:定时将内存数据全量保存到磁盘,生成紧凑的压缩文件
   - **混合持久化**:重写时先保存RDB格式,再追加增量AOF,兼顾恢复速度和数据完整性

4. **过期管理**:
   - **惰性删除**:访问键时检查过期,已过期则删除
   - **定期删除**:每秒执行10次,每次随机抽取20个键检查,若过期键占比>25%,继续循环
   - **时间轮**:高效管理大量定时任务,避免使用大量timer

5. **内存优化**:
   - 小对象使用特殊编码(如ziplist、intset)
   - 数据结构根据大小自动切换底层实现
   - 支持多种内存淘汰策略(LRU、LFU、TTL等)

6. **事务机制**:
   - 基于MULTI/EXEC实现事务
   - WATCH机制实现乐观锁
   - 版本号检测保证隔离性

7. **主从复制**:
   - 主节点处理写操作,从节点复制数据
   - 支持全量同步和增量同步
   - 哨兵机制实现自动故障转移

#### 4.1.2. 应用场景

GoCache 适用于以下典型应用场景:

**1. 零信任架构场景**
- 设备信任评分缓存(设备ID -> 信任分数、风险等级)
- 用户策略缓存(用户ID + 设备ID -> 访问策略JSON)
- 短期访问令牌存储(ZTNA临时令牌,1小时过期)
- MFA验证码存储(5分钟过期)

**2. 风控系统场景**
- 黑名单管理(恶意IP、设备ID集合,使用Set)
- 实时风险排行榜(用户风险分数,使用Sorted Set)
- 时间窗口限流(使用时间戳作为分数的Sorted Set)
- 用户访问频率计数(使用INCR原子操作)

**3. 审计与监控场景**
- 安全事件队列(使用List,IDS告警从左侧推入)
- 用户访问轨迹时间线(使用List)
- 异常行为统计(按频率排序的Sorted Set)

**4. 会话管理场景**
- 用户会话信息(使用Hash存储)
- 在线用户列表(使用Set)
- 会话超时管理(使用TTL)

**5. 分布式协作场景**
- 分布式锁(使用SETNX实现)
- 分布式限流(使用INCR+过期时间)
- 配置中心(使用Hash存储)

**典型事件流程**:

```
场景1: 用户登录验证(零信任架构)
1. 用户请求访问 -> 网关接收
2. 查询设备信任评分: GET device:12345:score (返回: 85)
3. 查询用户策略: HGETALL user:alice:policy
4. 评估通过 -> 生成临时令牌: SET token:abc "user_data" EX 3600
5. 记录访问日志: LPUSH access:alice "timestamp,ip,action"

场景2: 风控限流
1. 用户发起请求 -> 检查访问频率
2. 获取计数: GET ratelimit:user:123:202601101000
3. 若不存在,设置: SET ratelimit:user:123:202601101000 0 EX 60
4. 递增计数: INCR ratelimit:user:123:202601101000
5. 若超过阈值(如100),拒绝访问

场景3: 设备异常行为检测
1. 连续认证失败: INCR authfail:device:12345
2. 设置过期: EXPIRE authfail:device:12345 300 (5分钟)
3. 若失败次数>10: SADD blacklist:device 12345
4. 检查是否在黑名单: SISMEMBER blacklist:device 12345
```

#### 4.1.3. 对手分析

|对比项|GoCache|Redis|Memcached|
|---|---|---|---|
|实现语言|Go|C|C|
|数据结构|5种丰富数据结构|5种丰富数据结构|仅String|
|持久化|AOF+RDB+混合|RDB+AOF|不支持|
|并发模型|分片锁+协程|单线程+IO多路复用|多线程|
|性能|100,000+ QPS|150,000+ QPS|100,000+ QPS|
|内存优化|支持多种编码|支持多种编码|无特殊优化|
|淘汰策略|8种策略|8种策略|LRU|
|事务|支持(乐观锁)|支持(乐观锁)|不支持|
|优势|1. Go语言易维护<br>2. 架构清晰<br>3. 开发效率高|1. 性能最优<br>2. 功能最全<br>3. 生态成熟|1. 简单高效<br>2. 多线程性能好<br>3. 适合纯缓存场景|
|劣势|1. 性能略逊于C实现<br>2. 生态不如Redis|1. C语言维护难<br>2. 单线程模型受限|1. 无持久化<br>2. 数据结构单一<br>3. 无事务|

**借鉴点**:
- Redis的数据结构和算法设计(跳表、快速列表、压缩列表等)
- Redis的RESP协议设计(简单高效、可读性好)
- Redis的内存优化策略(小对象编码、数据结构自动切换)
- Memcached的多线程并发模型(虽未采用,但作为参考)

**创新点**:
- Go语言的协程+分片锁模型,平衡并发性能和开发效率
- 时间轮管理TTL,避免大量timer的开销
- 模块化设计,便于扩展和维护

### 4.2 方案选型

#### 核心方案对比

|评估准则|权重|评估方法|方案1: 单线程模型|方案2: 分片锁模型|方案3: 多线程模型|
|---|---|---|---|---|---|
|性能|30%|QPS测试|160,000 QPS|150,000 QPS|140,000 QPS|
|并发能力|25%|并发连接数|10,000+|10,000+|10,000+|
|开发复杂度|20%|代码量|中|低|高|
|锁竞争|15%|延迟P99|可能高(热点key)|低(分片)|中(全局锁)|
|可维护性|10%|代码可读性|高|高|中|


|备选方案名称|本方案的优点|本方案的风险和缺点|最终选择|
|---|---|---|---|
|方案1: 单线程模型|1. 实现简单,无锁竞争<br>2. 命令执行顺序保证<br>3. CPU缓存亲和性好|1. 无法利用多核<br>2. 热点key成为瓶颈<br>3. 慢命令阻塞后续命令|适用于简单场景,不满足高性能需求|
|方案2: 分片锁模型|1. 充分利用多核<br>2. 分片减少锁竞争<br>3. Go协程高效调度<br>4. 代码清晰易维护|1. 需要处理并发安全<br>2. 跨分片事务复杂<br>3. 需要实现版本控制|**推荐**(平衡性能、并发、开发效率)|
|方案3: 多线程模型|1. 充分利用多核<br>2. 成熟的并发模型|1. 全局锁竞争严重<br>2. 线程切换开销<br>3. 代码复杂度高<br>4. 调试困难|不推荐(锁竞争问题难解决)|

**选择方案2(分片锁模型)的原因**:
1. 利用Go语言的协程机制,高效处理并发连接
2. 分片锁将数据按哈希分散,每个分片独立加锁,大幅降低锁竞争
3. 相比多线程模型,协程更轻量,调度开销小
4. 相比单线程模型,能充分利用多核CPU
5. 通过版本号机制实现WATCH,解决跨分片事务问题

#### 持久化方案选型

|评估准则|权重|方案1: RDB|方案2: AOF|方案3: 混合持久化|
|---|---|---|---|---|
|数据完整性|30%|可能丢失较多数据|最多丢失1秒|最多丢失1秒|
|恢复速度|30%|快|慢|中等|
|文件大小|20%|小|大|较小(约为纯AOF的10%)|
|CPU开销|20%|高(fork子进程)|低|中等|

**最终选择:方案3(混合持久化)**
- AOF重写时生成RDB格式前置,记录重写时刻的数据快照
- 重写期间的新命令追加到RDB之后
- 兼顾数据完整性和恢复速度
- 文件体积相比纯AOF减小约90%
- 恢复时先加载RDB快照,再重放增量AOF日志

#### 数据结构编码选型

|数据结构|小数据量编码|大数据量编码|切换阈值|
|---|---|---|---|
|List|ziplist|linkedlist/quicklist|列表长度≥512或元素长度≥64字节|
|Hash|ziplist|hashtable|字段数量≥512或任意值大小≥64字节|
|Set|intset|hashtable|元素数量≥512或包含非整数|
|SortedSet|ziplist|skiplist+hashtable|元素数量≥128或成员大小≥64字节|

### 4.3 静态结构

```plantuml
@startuml GoCache架构图
skinparam monochrome true
package "TCP Layer" {
  [TCP Server
(std/net)]
}
package "Protocol Layer" {
  [Protocol Parser
(RESP)]
}
package "Router Layer" {
  [Command Router]
}
package "Database Engine" {
  database "DB 0" as db0
  database "DB 1" as db1
  database "DB..." as dbn
}
package "Data Layer" {
  [Data Dict
(Sharded)]
  [TTL Dict
(Sharded)]
  [Version Map
(Sharded)]
}
package "Data Structures" {
  [String]
  [List]
  [Hash]
  [Set]
  [SortedSet]
  [Bitmap]
}
package "Persistence" {
  [Persister
(AOF/RDB)]
}
package "TTL Management" {
  [TimeWheel
(TTL管理)]
}

[TCP Server
(std/net)] --> [Protocol Parser
(RESP)]
[Protocol Parser
(RESP)] --> [Command Router]
[Command Router] --> db0
[Command Router] --> db1
[Command Router] --> dbn

db0 --> [Data Dict
(Sharded)]
db0 --> [TTL Dict
(Sharded)]
db0 --> [Version Map
(Sharded)]

db0 --> [String]
db0 --> [List]
db0 --> [Hash]
db0 --> [Set]
db0 --> [SortedSet]
db0 --> [Bitmap]

db0 --> [Persister
(AOF/RDB)]
db0 --> [TimeWheel
(TTL管理)]
@enduml
```

**核心模块说明**:

**1. TCP Server 层**:
   - 基于标准库net包实现
   - 支持多协程并发处理连接
   - 每个连接一个协程,避免阻塞
   - 支持连接数限制和优雅关闭

**2. 协议解析层**:
   - 完整实现RESP协议解析
   - 支持流式解析,适合大文件传输
   - 支持所有RESP数据类型(Simple String、Error、Integer、Bulk String、Array)

**3. 命令路由层**:
   - 命令注册表(cmdTable)管理所有命令
   - 参数校验和预处理
   - 提取读写键,用于加锁
   - 支持事务状态管理

**4. 数据库引擎层**:
   - 多数据库支持(默认16个)
   - 分片并发字典(ConcurrentDict):
     * 使用FNV哈希算法计算分片
     * 分片数自动调整为2的幂次方
     * 每个分片独立读写锁
   - TTL管理器:
     * 单独的TTL字典
     * 时间轮实现高效过期检查
   - 版本管理器:
     * 支持WATCH乐观锁
     * 每个键维护版本号

**5. 数据结构层**:
   - **String**: SDS结构,带长度前缀,二进制安全
   - **List**:
     * 小数据量使用ziplist(压缩列表)
     * 大数据量使用linkedlist或quicklist
   - **Hash**:
     * 小数据量使用ziplist
     * 大数据量使用hashtable
   - **Set**:
     * 纯整数集合使用intset
     * 混合类型使用hashtable
   - **SortedSet**:
     * 小数据量使用ziplist
     * 大数据量使用skiplist+hashtable组合
     * 跳表层数最大32层

**6. 持久化层**:
   - **AOF**:
     * 异步写入通道缓冲
     * 支持三种fsync策略(always、everysec、no)
     * 支持AOF重写
   - **RDB**:
     * 全量快照生成
     * 二进制格式,体积小
     * 加载速度快
   - **混合持久化**:
     * AOF重写时生成RDB前置
     * RDB之后追加增量命令

**7. 时间轮模块**:
   - 高效管理大量定时任务
   - 避免使用大量timer
   - 支持精确到毫秒的TTL

### 4.4. 对软件总体架构的影响

|情况分类|是否对总设有影响|
|---|---|
|1.本次新增或调整的模块对总体架构是否有影响|**是** - 这是全新的独立系统架构|
|2.本次新增或调整的模块对总体架构有一定程度的影响,但涉及的模块少于3个|**否** - 采用完整自包含架构|
|3.本次新增或调整的模块对总体架构有较大影响,需要对原有软件架构进行较大调整或者重新设计|**否** - 独立设计实现|

**架构影响说明**:
GoCache采用全新的分层模块化架构设计,各层职责清晰,相互独立:
- 网络层与业务层完全分离,便于协议升级
- 数据结构独立封装,便于扩展新的数据类型
- 持久化模块可插拔,便于支持多种持久化策略
- 命令注册机制,便于添加新命令
- 预留集群接口,便于未来扩展分布式能力

### 4.5. 概要流程

#### 4.5.1. 客户端命令执行流程

```plantuml
@startuml 客户端命令执行流程
skinparam monochrome true
start

:Client;
:发送命令 SET key value;
note right: RESP格式: *3
$3
SET
$3
key
$5
value

partition "Protocol Parser" {
  :解析 RESP 协议;
  :读取数组头 '*3';
  :读取各元素长度和内容;
  :生成 CmdLine;
}

partition "Command Router" {
  :从 cmdTable 查找命令;
  :参数校验;
  :预处理: 提取读写键;
  if (InMultiState?) then (是)
    :入队返回 QUEUED;
    stop;
  else (否)
    :继续执行;
  endif
}

partition "Database Engine" {
  :计算分片;
  :加锁 RWLocks(writeKeys, readKeys);
  
  :检查key是否过期;
  :执行 SET 逻辑;
  :更新 DataDict[key];
  :设置 TTL;
  :增加版本号;
  
  :记录 AOF;
  :解锁 RWUnLocks(writeKeys, readKeys);
}

:生成 RESP Reply;
:发送回 Client;

stop
@enduml
```

#### 4.5.2. AOF 持久化流程

**正常写入流程**:

```plantuml
@startuml AOF持久化写入流程
skinparam monochrome true
start

:Command Execution
命令执行完成;

partition "AOF Handler" {
  :SaveCmdLine(dbIndex, cmdLine);
  :将命令放入 aofChan;
  note right: 缓冲通道
大小 1<<20
}

partition "Listen Goroutine (异步)" {
  :从 aofChan 读取命令;
  
  :writeAof();
  :检查是否需要 SELECT 数据库;
  :序列化为 RESP 格式;
  :写入 aofFile;
  
  switch (fsync 策略)
  case (always)
    :每次写后 fsync;
    note right: 最安全,性能最差
  case (everysec)
    :每秒 fsync 一次;
    note right: 推荐
平衡性能和安全
  case (no)
    :由 OS 决定;
    note right: 性能最优
可能丢失数据
  endswitch
}

stop
@enduml
```

**AOF 重写流程**:

```plantuml
@startuml AOF重写流程
skinparam monochrome true
start

:BGRewriteAOF (后台重写);
:暂停 AOF 写入;
note right: pausingAof.Lock
重写期间新命令记录到
rewrite buffer

:创建临时文件;

:遍历当前 DB 所有数据;
repeat
  :ForEach 遍历 key;
  :检查 key 是否过期;
  :将数据转换为命令;
  :写入临时 AOF 文件;
  note right: 先写入 RDB 格式前缀
再重放 rewrite buffer
repeat (还有数据?) is (否)
-> 是;

:原子替换文件;
note right: rename 临时文件为
正式 AOF 文件
操作系统保证原子性

:恢复 AOF 写入;
note right: pausingAof.Unlock

:清理 rewrite buffer;

stop
@enduml
```

**优势**:
- RDB格式快速恢复
- AOF格式保证数据完整性
- 文件体积比纯AOF减小约90%
- 恢复时先加载RDB快照,再重放少量增量日志

#### 4.5.3. 键过期处理流程

**时间轮过期检查**:

```plantuml
@startuml 时间轮TTL过期检查
skinparam monochrome true
start

:TimeWheel 后台运行;
:扫描到期的定时任务;

repeat
  :获取到期 taskKey;
  :格式: "expire:key";
  
  :加锁 RWLocks([key], nil);
  
  :检查 TTL;
  :rawExpireTime, ok := ttlMap.Get(key);
  if (已删除或永不过期?) then (是)
    :解锁;
  else (否)
    if (已过期?) then (是)
      :删除键;
      note right: 从 dataDict 删除
从 ttlMap 删除
从 versionMap 删除
触发 deleteCallback
    else (否)
      :未过期;
    endif
  endif
  
  :解锁 RWUnLocks([key], nil);
  
repeat (还有任务?) is (否)
-> 是;

stop
@enduml
```

**惰性删除**:

```
GetEntity(key)
  │
  ├─ 1. raw, exists := dataDict.Get(key)
  │     - if !exists { return nil, false }
  │
  ├─ 2. 检查是否过期
  │     - rawExpireTime, ok := ttlMap.Get(key)
  │     - if !ok { return raw, true } (无过期时间)
  │     - expireTime := rawExpireTime.(time.Time)
  │     - if !time.Now().After(expireTime) { return raw, true } (未过期)
  │
  ├─ 3. 过期,删除键
  │     - Remove(key)
  │
  └─ 4. return nil, false
```

**定期删除**:

```
每秒执行 10 次
  │
  ├─ 每次随机抽取 20 个键
  │
  ├─ 检查这些键是否过期
  │     - 过期则删除
  │
  └─ 如果过期键占比 > 25%
        - 继续循环抽取和检查
        - 避免长时间阻塞,设置上限
```

#### 4.5.4. 事务执行流程

```
Client
  │
  ├─ 1. MULTI
  │     └─> 设置 MultiState = true
  │           初始化命令队列
  │
  ├─ 2. SET key1 value1
  │     └─> EnqueueCmd (加入队列)
  │           返回 QUEUED
  │
  ├─ 3. GET key2
  │     └─> EnqueueCmd
  │           返回 QUEUED
  │
  ├─ 4. WATCH key3
  │     └─> 记录 key3 及其版本号
  │           watching[key3] = versionMap[key3]
  │
  ├─ 5. EXEC
  │     │
  │     ├─ 6. 提取所有命令
  │     │
  │     ├─ 7. 分析读写键
  │     │   - 遍历所有命令
  │     │   - 提取所有写键和读键
  │     │
  │     ├─ 8. 按分片顺序加锁
  │     │   - RWLocks(writeKeys, readKeys)
  │     │   - 避免死锁
  │     │
  │     ├─ 9. 检查 WATCH
  │     │   - for key, oldVersion in watching:
  │     │       if versionMap[key] != oldVersion:
  │     │         返回 nil,事务中止
  │     │
  │     ├─ 10. 执行命令
  │     │   - 逐条执行命令
  │     │   - 生成结果数组
  │     │   - 如果某条命令失败:
  │     │         * 已执行的不回滚(与Redis一致)
  │     │         * 后续命令继续执行
  │     │
  │     ├─ 11. 提交
  │     │   - 增加写键的版本号
  │     │   - 清空 watching
  │     │   - 清空 MultiState
  │     │
  │     └─ 12. 解锁并返回结果
  │           - RWUnLocks(writeKeys, readKeys)
  │           - 返回结果数组
```

#### 4.5.5. 可调试性机制分析及设计

**调试难点**:
1. 并发竞争导致的问题难以复现(如多客户端同时修改同一键)
2. 慢查询难以定位(某条命令执行时间过长)
3. 内存泄漏难以排查(如时间轮任务未正确清理)
4. AOF数据损坏难以定位和恢复

**调试方案**:

**1. 慢查询日志**:
```
记录执行时间超过阈值的命令
- 配置: slowlog-log-slower-than (微秒)
- 保存最近的 N 条: slowlog-max-len
- 查询命令: SLOWLOG GET [n]
- 记录内容: 命令、执行时间、时间戳、客户端信息
```

**2. INFO 状态查询**:
```
INFO 命令查看服务器状态
- server: 服务器版本、运行时间、客户端连接数
- memory: 内存使用、内存碎片率、键数量
- persistence: AOF/RDB状态、最后一次保存时间
- stats: 命令执行统计、连接统计
- replication: 主从复制状态
```

**3. MONITOR 监控**:
```
实时显示所有执行的命令
- 生产环境慎用(性能影响大)
- 开发调试阶段使用
- 可以看到完整的命令序列
```

**4. DEBUG 系列命令**:
```
- DEBUG OBJECT key: 查看键的内部信息
- DEBUG SDS: 显示SDS详细信息
- DEBUG STATS: 显示详细统计信息
```

**5. AOF 校验工具**:
```
- 提供 AOF 文件校验命令
- 检查格式是否正确
- 尝试加载并验证数据一致性
```

#### 4.5.6. 可测试性机制分析及设计

**测试难点**:
1. 并发测试场景复杂(需要模拟多客户端同时操作)
2. 时间相关的测试难以控制(如TTL过期)
3. 持久化测试耗时(需要等待文件写入和重启)
4. 事务并发冲突难以构造

**测试方案**:

**1. 时间控制**:
```
提供时间控制接口,便于测试:
- 可配置的时间源(TimeProvider)
- 测试时可注入虚拟时间
- 便于加速时间流逝,测试TTL过期
```

**2. Mock 支持**:
```
- Connection 支持 stub 注入
- Persister 支持内存模式(不写文件)
- 便于单元测试,不依赖文件系统
```

**3. 测试命令**:
```
提供专用测试命令:
- DEBUG SLEEP seconds: 模拟慢命令
- DEBUG POPULATE count: 快速生成测试数据
- FLUSHALL: 清空所有数据
```

**4. 集成测试脚本**:
```
- 提供完整的测试脚本
- 覆盖主要功能点
- 自动化测试流程
```

#### 4.5.7. 可扩展可复用设计

**1. 命令扩展**:
```
通过 registerCommand 注册新命令:
- name: 命令名称
- executor: 执行函数
- prepare: 预处理函数(提取读写键)
- undo: 回滚函数(事务用)
- arity: 参数个数
- flags: 命令标志(只读、写操作等)

示例:
registerCommand(command{
    name: "GET",
    executor: execGet,
    prepare: func(args [][]byte) ([]string, []string) {
        return nil, []string{string(args[0])}
    },
    arity: 2,
    flags: cmdReadonly,
})
```

**2. 数据结构扩展**:
```
DataEntity 支持任意类型:
type DataEntity struct {
    Data interface{}  // 可以是任何自定义类型
}

添加新数据结构:
1. 实现数据结构接口
2. 实现 EntityToCmd 转换函数
3. 注册相关命令
```

**3. 持久化策略扩展**:
```
支持自定义持久化策略:
- 实现 Persister 接口
- 配置不同的 fsync 策略
- 支持多种持久化后端(如S3、HDFS)
```

**4. 编码方式扩展**:
```
数据结构编码可配置:
- ziplist 编码阈值可调
- 可添加新的编码方式
- 根据硬件特性优化编码
```

#### 4.5.8. 系统隐私设计

**隐私目标**:
- 不主动收集用户操作数据
- 日志中不包含敏感信息
- 支持密码认证保护数据
- 支持数据加密存储(可选)

**隐私设计**:

**1. 日志脱敏**:
```
敏感命令参数不记录:
- AUTH 命令的密码参数不记录到日志
- 用户提供的数据中包含敏感字段时不记录
- 记录为: AUTH ****** 或 SET key ******
```

**2. 密码保护**:
```
- 支持密码认证机制
- 密码不以明文存储(使用哈希)
- 配置文件中的密码加密存储
```

**3. 访问控制**:
```
- 支持IP白名单
- 支持用户名密码认证
- 支持命令级别权限控制
```

**4. 数据加密**:
```
- 支持传输层加密(TLS)
- 支持数据持久化加密(可选)
- 密钥管理机制
```

#### 4.5.9. 安全性设计

##### 威胁建模分析

|威胁类型|威胁描述|影响|风险等级|缓解措施|
|---|---|---|---|---|
|未授权访问|无密码认证情况下任何客户端可连接|数据泄露|高|支持AUTH密码认证,IP白名单|
|命令注入|恶意构造特殊命令导致服务崩溃|服务不可用|中|命令参数严格校验,长度限制|
|慢查询攻击|发送耗时操作占用资源(如KEYS *)|性能下降|高|慢查询日志+超时保护,KEYS替换为SCAN|
|DoS攻击|大量连接耗尽资源|服务不可用|高|连接数限制,超时控制|
|AOF篡改|修改AOF文件注入恶意命令|数据一致|中|AOF校验机制,文件权限控制|
|内存泄露|大量数据写入导致内存溢出|服务崩溃|高|maxmemory限制,淘汰策略|
|信息泄露|INFO/MONITOR等命令暴露敏感信息|信息泄露|低|命令权限控制,日志脱敏|

##### 安全设计

**1. 认证机制**:
```go
// AUTH 命令实现
func Auth(c Connection, args [][]byte) Reply {
    if !config.Properties.RequirePass {
        return MakeErrReply("ERR AUTH failed")
    }
    password := string(args[0])
    if password != config.Properties.RequirePass {
        return MakeErrReply("ERR invalid password")
    }
    c.SetAuthenticated()
    return MakeOkReply()
}

// 所有命令执行前检查认证
func Exec(c Connection, cmdLine [][]byte) Reply {
    if !c.IsAuthenticated() && cmdName != "auth" {
        return MakeErrReply("NOAUTH Authentication required")
    }
    // ...
}
```

**2. 命令重命名和禁用**:
```go
// 配置文件支持
rename-command KEYS ""
rename-command FLUSHALL ""
rename-command CONFIG "b840fc02d524045429941cc15f59e41cb7be6c52"

// 命令查找时检查
func getCommand(name string) (*command, bool) {
    // 检查是否被重命名
    if renamed, ok := renamedCommands[name]; ok {
        if renamed == "" {
            return nil, false  // 禁用
        }
        name = renamed
    }
    return cmdTable[name]
}
```

**3. 资源限制**:
```go
// 连接数限制
if clientCounter.Count() >= maxClients {
    return MakeErrReply("ERR max number of clients reached")
}

// 内存限制
if getUsedMemory() >= maxmemory {
    // 触发淘汰策略
    evictKeys()
}

// 慢查询超时
ctx, cancel := context.WithTimeout(context.Background(), slowlogMaxTimeout)
defer cancel()
```

**4. 访问控制**:
```go
// IP白名单
if !isIPAllowed(client.RemoteIP()) {
    return MakeErrReply("ERR access denied")
}

// 命令权限控制
if !user.HasPermission(cmdName) {
    return MakeErrReply("ERR command not allowed")
}
```

#### 4.5.10. 可靠性设计

**1. 承载载体可靠**

**进程/服务**:
- **Panic 恢复**: 每个协程使用 recover() 捕获 panic
- **优雅关闭**:
  * 监听系统信号(SIGTERM, SIGINT)
  * 停止接受新连接
  * 等待现有请求处理完成
  * 刷盘 AOF 缓冲
  * 关闭所有连接
  * 退出进程
- **进程监控**: 支持外部监控和管理

**数据/文件**:
- **AOF 文件校验**:
  * 写入时校验格式
  * 重写时验证数据一致性
  * 提供校验工具
- **RDB 加载错误恢复**:
  * 加载失败记录详细日志
  * 支持部分加载(跳过损坏部分)
- **临时文件原子替换**:
  * 使用 rename() 系统调用
  * 操作系统保证原子性

**2. 周边无影响**

资源隔离:
```
- 连接数限制(MaxClients)
- 内存使用限制(maxmemory)
- 单个键大小限制(512MB)
- 慢查询超时限制
- 批量操作命令数量限制(MSET/MGET建议不超过100个键)
```

**3. 业务流程可靠**

|功能点|失效模式|影响|改进措施|
|---|---|---|---|
|AOF 写入|磁盘满|命令丢失|返回错误,不阻塞业务,触发告警|
|AOF 重写|内存不足|重写失败|释放重写中间状态,下次重试|
|RDB 生成|fork失败|快照失败|记录日志,下次重试,不影响主流程|
|键过期|时间轮停止|内存占用增加|定期检查机制兜底|
|主从同步|网络断开|复制中断|自动重连+增量同步|
|命令执行|panic|连接断开|recover捕获,记录日志,关闭连接|
|事务执行|WATCH冲突|事务中止|返回nil,客户端可重试|

**FMEA 分析示例**:

|功能点:事务执行|---|---|---|
|---|---|---|---|
|失效模式|影响|严重度|改进措施|
|WATCH检测到冲突|事务中止,返回nil|中|返回明确错误码,客户端可重试|
|命令执行失败|已执行命令不回滚|中|文档明确说明,客户端处理错误|
|加锁超时|等待时间过长|中|优化锁粒度,避免长事务|
|版本号溢出|版本号重置|低|使用64位版本号,几乎不会溢出|

#### 4.5.11. 可维护设计

**1. 模块化架构**:
- 清晰的职责划分
- 接口定义明确
- 便于定位问题

**2. 日志系统**:
- 分级日志(DEBUG、INFO、WARN、ERROR)
- 结构化日志(JSON格式)
- 支持日志轮转

**3. 监控指标**:
- INFO 命令查看服务器状态
- 内存使用、连接数、命令统计
- 可接入外部监控系统

**4. 配置管理**:
- 配置文件统一管理
- 支持热加载(CONFIG SET)
- 配置验证

#### 4.5.12. 跨平台设计和平台差异处理

**跨平台支持**:
- Go 语言天然跨平台
- 编译为单一可执行文件
- 支持Linux、macOS、Windows

**平台差异处理**:
```go
// 文件路径处理
import "path/filepath"
configPath := filepath.Join(configDir, "gocache.conf")

// 系统调用判断
if runtime.GOOS == "windows" {
    // Windows 特定处理
} else {
    // Unix 特定处理
}

// 信号处理
signals := []os.Signal{syscall.SIGTERM, syscall.SIGINT}
if runtime.GOOS != "windows" {
    signals = append(signals, syscall.SIGHUP)
}
```

### 4.6. 方案风险分析

|风险点|风险预研结果/风险规避措施|
|---|---|
|分片锁性能问题|采用分片锁减少竞争,分片数可配置(默认16),通过压力测试验证性能达到目标|
|时间轮TTL精度|时间轮精度设置为1毫秒,满足TTL毫秒级精度要求,最坏情况误差<2ms|
|内存占用不可控|实现maxmemory限制和淘汰策略,支持8种淘汰策略,内存使用可控|
|并发事务复杂度|通过版本号机制实现WATCH,跨分片事务需要加多个分片的锁,复杂度可控|
|持久化性能影响|AOF异步写入,不阻塞主流程,重写在后台进行,不影响服务|
|数据结构编码切换|数据结构自动切换编码,切换阈值可配置,对用户透明|
|大值传输性能|512MB单值支持,分批传输,避免内存一次性分配|
|慢命令阻塞|实现慢查询日志,识别慢命令,建议用户使用SCAN替代KEYS|
|连接泄露|实现连接超时机制,自动清理僵尸连接|
|panic导致服务崩溃|每个协程使用recover捕获panic,记录日志,不影响其他协程|

---

# 5. 数据结构设计

### 5.1. 配置文件定义

**文件路径**:`gocache.conf` 或通过环境变量 `GOCACHE_CONFIG` 指定

|配置项|作用|默认值|取值范围|
|---|---|---|---|
|bind|监听地址|127.0.0.1|合法IP地址或0.0.0.0|
|port|监听端口|6379|1-65535|
|databases|数据库数量|16|1-256|
|maxclients|最大客户端数|10000|1-100000|
|maxmemory|最大内存限制|0(无限制)|字节数,支持KB/MB/GB|
|maxmemory-policy|内存淘汰策略|noeviction|noeviction/allkeys-lru/volatile-lru/allkeys-lfu/volatile-lfu/allkeys-random/volatile-random/volatile-ttl/allkeys-ttl|
|appendonly|启用AOF|no|yes/no|
|appendfilename|AOF文件名|appendonly.aof|合法文件名|
|appendfsync|AOF刷盘策略|everysec|always/everysec/no|
|aof-use-rdb-preamble|混合持久化|yes|yes/no|
|dbfilename|RDB文件名|dump.rdb|合法文件名|
|save|RDB保存规则|3600 1 300 100 60 10000|秒数 修改次数|
|requirepass|密码|""|字符串,建议≥16字符|
|timeout|客户端空闲超时|0(无限制)|秒数|
|tcp-keepalive|TCP keepalive|300|秒数|
|slowlog-log-slower-than|慢查询阈值|10000|微秒|
|slowlog-max-len|慢查询日志长度|128|1-1000|
|hash-max-ziplist-entries|Hash ziplist阈值|512|1-10000|
|hash-max-ziplist-value|Hash ziplist值阈值|64|字节|
|list-max-ziplist-size|List ziplist阈值|-2|-5到64|
|set-max-intset-entries|Set intset阈值|512|1-10000|
|zset-max-ziplist-entries|SortedSet ziplist阈值|128|1-10000|
|zset-max-ziplist-value|SortedSet ziplist值阈值|64|字节|
|hz|过期检查频率|10|1-500|
|dynamic-hz|动态频率|yes|yes/no|

### 5.2. 全局数据结构定义

#### Server 结构

|结构说明|GoCache 服务器实例,管理所有资源|---|---|
|---|---|---|---|
|**结构定义**|```go type Server struct { dbSet []*atomic.Value hub *pubsub.Hub persister *aof.Persister role int32 slaveStatus *slaveStatus masterStatus *masterStatus insertCallback database.KeyEventCallback deleteCallback database.KeyEventCallback slogLogger *SlowLogger }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|dbSet|[0, 256]|数据库集合,每个元素是 *DB 的 atomic.Value|
|---|hub|非空指针|发布订阅中心|
|---|persister|指针或 nil|AOF 持久化器|
|---|role|masterRole/slaveRole|服务器角色(主/从)|
|---|slaveStatus|非空指针|从节点状态|
|---|masterStatus|非空指针|主节点状态|
|---|insertCallback|函数或 nil|键插入回调|
|---|deleteCallback|函数或 nil|键删除回调|
|---|slogLogger|非空指针|慢查询日志器|

#### DB 结构

|结构说明|单个数据库实例|---|---|
|---|---|---|---|
|**结构定义**|```go type DB struct { index int data *dict.ConcurrentDict ttlMap *dict.ConcurrentDict versionMap *dict.ConcurrentDict addAof func(CmdLine) insertCallback database.KeyEventCallback deleteCallback database.KeyEventCallback }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|index|[0, 255]|数据库索引|
|---|data|非空指针|数据字典,key -> DataEntity,分片锁|
|---|ttlMap|非空指针|TTL 字典,key -> expirationTime,分片锁|
|---|versionMap|非空指针|版本字典,key -> version,分片锁|
|---|addAof|函数|AOF 写入函数|
|---|insertCallback|函数或 nil|键插入回调|
|---|deleteCallback|函数或 nil|键删除回调|

#### DataEntity 结构

|结构说明|数据实体,统一封装所有数据类型|---|---|
|---|---|---|---|
|**结构定义**|```go type DataEntity struct { Data interface{} }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|Data|指针类型|实际数据,可能是 *String, *List, *Hash, *Set, *SortedSet|

#### ConcurrentDict 结构

|结构说明|并发字典,分片锁实现|---|---|
|---|---|---|---|
|**结构定义**|```go type ConcurrentDict struct { table []*shard count int32 shardCount int } type shard struct { m map[string]interface{} mutex sync.RWMutex }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|table|长度 >= 16|分片表,每个分片独立读写锁|
|---|count|>= 0|元素总数(原子计数)|
|---|shardCount|2^n|分片数(自动调整为 2 的幂)|
|**分片计算**|spread(key): 1. hash = fnv32(key) 2. index = hash % shardCount 3. return index|||

#### String 数据结构

|结构说明|字符串数据结构,SDS实现|---|---|
|---|---|---|---|
|**结构定义**|```go type String struct { value string // 或 []byte 用于二进制安全 }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|value|字节数组|字符串值,二进制安全|

#### List 数据结构

|结构说明|列表数据结构,根据大小自动切换|---|---|
|---|---|---|---|
|**结构定义**|```go // 小数据量: ziplist type Ziplist struct { bytes []byte entries int } // 大数据量: linkedlist type LinkedList struct { head *listNode tail *listNode length int }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|bytes|字节数组|压缩列表编码|
|---|entries|>= 0|元素数量|
|---|head/tail|指针或 nil|链表头尾节点|
|---|length|>= 0|链表长度|

#### Hash 数据结构

|结构说明|哈希数据结构,根据大小自动切换|---|---|
|---|---|---|---|
|**结构定义**|```go // 小数据量: ziplist type Ziplist struct { bytes []byte entries int } // 大数据量: hashtable type HashTable struct { m map[string]string }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|bytes|字节数组|压缩列表编码:field1,value1,field2,value2...|
|---|m|非空 map|字段-值映射|

#### Set 数据结构

|结构说明|集合数据结构,根据类型自动切换|---|---|
|---|---|---|---|
|**结构定义**|```go // 纯整数: intset type Intset struct { contents []uint64 encoding uint8 length int16 } // 混合类型: hashtable type HashSet struct { m map[string]struct{} }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|contents|字节数组|整数数组|
|---|encoding|int8/int16/int32|编码格式|
|---|length|>= 0|元素数量|
|---|m|非空 map|成员集合(使用空struct节省内存)|

#### SortedSet 数据结构

|结构说明|有序集合数据结构,根据大小自动切换|---|---|
|---|---|---|---|
|**结构定义**|```go // 小数据量: ziplist type Ziplist struct { bytes []byte entries int } // 大数据量: skiplist + hashtable type SortedSet struct { dict map[string]*Element skiplist *skiplist } type Element struct { Member string Score float64 }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|bytes|字节数组|压缩列表编码:score1,member1,score2,member2...|
|---|dict|非空 map|member -> Element 映射,O(1)查找|
|---|skiplist|非空指针|跳表,按 score 排序,O(log n)范围查询|
|---|Member|字符串|成员名|
|---|Score|双精度浮点|分数,范围-17亿<score<17亿|

#### Skiplist 跳表结构

|结构说明|跳表,有序集合底层实现|---|---|
|---|---|---|---|
|**结构定义**|```go type skiplist struct { header *node length int level int } type node struct { Element forward []*node backward *node }```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|header|非空指针|头节点|
|---|length|>= 0|节点数量|
|---|level|[1, 32]|最大层数|
|---|forward|节点指针数组|前进指针数组,最大32层|
|---|backward|指针或 nil|后退指针|
|**时间复杂度**|Add: O(log n) <br> Remove: O(log n) <br> GetRank: O(log n) <br> Range: O(log n + m)|||

#### Command 命令结构

|结构说明|命令定义|---|---|
|---|---|---|---|
|**结构定义**|```go type command struct { name string // 命令名称 executor ExecFunc // 执行函数 prepare PreFunc // 预处理函数 undo UndoFunc // 回滚函数 arity int // 参数个数(<0表示可变参数) flags int // 标志位 } type ExecFunc func(db *DB, args [][]byte) Reply type PreFunc func(args [][]byte) ([]string, []string) // 返回(写键,读键) type UndoFunc func(db *DB, args [][]byte) []CmdLine```|---|---|
|**字段说明**|**字段名**|**取值范围**|**说明**|
|---|name|字符串|命令名称,大写|
|---|executor|函数|执行函数|
|---|prepare|函数|预处理函数,提取读写键|
|---|undo|函数|回滚函数(事务用)|
|---|arity|int|参数个数,-2表示≥1,-3表示≥2|
|---|flags|位掩码|cmdReadonly(只读)、cmdWrite(写操作)|

---

# 6. 流程设计

## 6.1. 数据库引擎模块 (database)

### 6.1.1. 静态结构

**职责定义**:
- 管理多个数据库实例(默认16个)
- 提供命令执行入口
- 管理AOF持久化
- 管理主从复制状态
- 管理发布订阅
- 管理慢查询日志

**组成结构**:
```
Server
├── dbSet []*atomic.Value (多数据库)
├── hub *pubsub.Hub (发布订阅)
├── persister *aof.Persister (持久化)
├── slaveStatus *slaveStatus (从节点状态)
├── masterStatus *masterStatus (主节点状态)
└── slogLogger *SlowLogger (慢查询)
```

### 6.1.2. 处理流程

#### 命令执行主流程

```go
func (server *Server) Exec(c Connection, cmdLine CmdLine) Reply {
    // 1. 特殊命令处理:PING, AUTH, INFO
    cmdName := strings.ToLower(string(cmdLine[0]))
    if cmdName == "ping" {
        return execPing(c, server, cmdLine[1:])
    }
    if cmdName == "auth" {
        return execAuth(c, server, cmdLine[1:])
    }
    if cmdName == "info" {
        return execInfo(c, server, cmdLine[1:])
    }

    // 2. 认证检查
    if !c.IsAuthenticated() {
        return MakeErrReply("NOAUTH Authentication required")
    }

    // 3. 慢查询记录
    startTime := time.Now()

    // 4. 从节点只读检查
    if server.getRole() == slaveRole && !isReadOnlyCommand(cmdName) {
        return MakeErrReply("READONLY You can't write against a read only slave")
    }

    // 5. 获取数据库
    db := server.selectDB(c.GetDBIndex())
    if db == nil {
        return MakeErrReply("ERR invalid DB index")
    }

    // 6. 执行命令
    result := db.Exec(c, cmdLine)

    // 7. 记录慢查询
    server.slogLogger.Record(startTime, cmdLine, c.Name())

    return result
}
```

#### 数据库切换流程

```go
func execSelect(c Connection, server *Server, args [][]byte) Reply {
    if len(args) != 1 {
        return MakeErrReply("ERR wrong number of arguments")
    }

    dbIndex, err := strconv.Atoi(string(args[0]))
    if err != nil {
        return MakeErrReply("ERR invalid DB index")
    }

    if dbIndex >= len(server.dbSet) || dbIndex < 0 {
        return MakeErrReply("ERR DB index is out of range")
    }

    c.SelectDB(dbIndex)
    return MakeOkReply()
}
```

#### FLUSHDB/FLUSHALL 流程

```go
func execFlushDB(c Connection, server *Server, args [][]byte) Reply {
    dbIndex := c.GetDBIndex()
    db := server.selectDB(dbIndex)

    // 清空数据库
    db.data.Clear()
    db.ttlMap.Clear()
    db.versionMap.Clear()

    return MakeOkReply()
}

func execFlushAll(c Connection, server *Server, args [][]byte) Reply {
    for _, dbVal := range server.dbSet {
        db := dbVal.Load().(*database.DB)
        db.data.Clear()
        db.ttlMap.Clear()
        db.versionMap.Clear()
    }

    return MakeOkReply()
}
```

### 6.1.3. 关键算法描述

#### 并发字典查询算法

**数据结构**:分片锁字典

**算法流程**:
```
算法:Get(key)
输入:key 字符串
输出:value, exists

1. hash = fnv32(key)  // 使用FNV哈希算法
2. index = hash % shardCount  // 计算分片索引
3. shard = table[index]  // 获取分片
4. shard.RLock()  // 加读锁
5. value, exists = shard.m[key]  // 查询
6. shard.RUnlock()  // 解锁
7. return value, exists
```

**性能**:
- 最好情况:O(1)
- 最坏情况:O(1)
- 并发场景:分片减少锁竞争,16个分片理论上竞争降至1/16

#### 并发字典写入算法

```
算法:Put(key, value)
输入:key, value
输出:是否新增(1=新增,0=更新)

1. hash = fnv32(key)
2. index = hash % shardCount
3. shard = table[index]
4. shard.Lock()  // 加写锁
5. _, exists := shard.m[key]
6. shard.m[key] = value
7. atomic.AddInt32(&count, 1)  // 原子递增总数
8. shard.Unlock()
9. if exists { return 0 } else { return 1 }
```

### 6.1.4. 数据结构定义

**CmdLine 命令行**:
```go
type CmdLine = [][]byte  // 命令行,如 [][]byte{[]byte("SET"), []byte("key"), []byte("value")}
```

**Reply 返回值接口**:
```go
type Reply interface {
    ToBytes() []byte  // 序列化为RESP格式
}

type StandardReply struct {
    code byte
    data interface{}
}
```

### 6.1.5. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|Exec|执行命令|[in]c Connection:客户端连接<br>[in]cmdLine CmdLine:命令行<br>return Reply:返回结果|主入口,处理所有命令|
|selectDB|选择数据库|[in]dbIndex int:数据库索引<br>return *DB:数据库实例<br>return error:错误|索引越界返回错误|
|flushDB|清空数据库|[in]dbIndex int:数据库索引<br>return Reply:返回结果|清空指定数据库|
|flushAll|清空所有数据库|return Reply:返回结果|清空所有16个数据库|
|AfterClientClose|客户端关闭回调|[in]c Connection:客户端连接|清理订阅等资源|
|Close|关闭服务器|-|优雅关闭,刷盘AOF|

### 6.1.6. 设计要点检视

|可维护/可调试措施|慢查询日志记录执行时间超过阈值的命令;INFO命令查看服务器状态;Panic恢复机制;结构化日志|
|---|---|
|**可测试性**|ConnectionFactory支持stub注入;内存模式支持无文件运行;时间控制接口|
|**自动化测试支持**|提供单元测试覆盖核心逻辑;集成测试脚本模拟各种场景|
|**可扩展性**|支持动态添加命令;数据库数量可配置;持久化策略可配置|
|**稳定性保证措施**|Panic恢复;资源限制(MaxClients,maxmemory);AOF校验;优雅关闭|
|**工作量估算**|约60人天(需求10+设计15+编码25+测试10)|

---

## 6.2. 单数据库模块 (database/DB)

### 6.2.1. 静态结构

**职责定义**:
- 管理单个数据库的所有数据
- 执行具体命令逻辑
- 管理TTL和版本号
- 支持事务机制

**组成结构**:
```
DB
├── data *ConcurrentDict (数据字典)
├── ttlMap *ConcurrentDict (TTL字典)
├── versionMap *ConcurrentDict (版本字典)
├── addAof func(CmdLine) (AOF写入函数)
└── insertCallback/deleteCallback (回调函数)
```

### 6.2.2. 处理流程

#### 命令执行流程

```go
func (db *DB) Exec(c Connection, cmdLine CmdLine) Reply {
    cmdName := strings.ToLower(string(cmdLine[0]))

    // 1. 事务控制命令
    if cmdName == "multi" {
        return startMulti(c)
    }
    if cmdName == "exec" {
        return execExec(db, c)
    }
    if cmdName == "discard" {
        return execDiscard(c)
    }
    if cmdName == "watch" {
        return execWatch(db, c, cmdLine[1:])
    }
    if cmdName == "unwatch" {
        return execUnwatch(c)
    }

    // 2. MULTI状态下入队
    if c.InMultiState() {
        return enqueueCmd(c, cmdLine)
    }

    // 3. 正常命令执行
    return db.execNormalCommand(cmdLine)
}
```

#### 正常命令执行

```go
func (db *DB) execNormalCommand(cmdLine CmdLine) Reply {
    // 1. 查找命令
    cmdName := strings.ToLower(string(cmdLine[0]))
    cmd, ok := cmdTable[cmdName]
    if !ok {
        return MakeErrReply("ERR unknown command")
    }

    // 2. 参数校验
    arity := cmd.arity
    if arity > 0 {
        if len(cmdLine) != arity {
            return MakeErrReply("ERR wrong number of arguments")
        }
    } else if arity < 0 {
        if len(cmdLine) < -arity {
            return MakeErrReply("ERR wrong number of arguments")
        }
    }

    // 3. 预处理:提取读写键
    prepare := cmd.prepare
    writeKeys, readKeys := prepare(cmdLine[1:])

    // 4. 增加版本号(写键)
    for _, key := range writeKeys {
        db.addVersion(key)
    }

    // 5. 加锁
    db.RWLocks(writeKeys, readKeys)
    defer db.RWUnLocks(writeKeys, readKeys)

    // 6. 检查键是否过期
    for _, key := range append(writeKeys, readKeys...) {
        db.ExpireIfNeeded(key)
    }

    // 7. 执行命令
    result := cmd.executor(db, cmdLine[1:])

    // 8. 记录AOF(写命令)
    if cmd.flags&cmdWrite != 0 && db.addAof != nil {
        db.addAof(cmdLine)
    }

    return result
}
```

#### 获取数据实体

```go
func (db *DB) GetEntity(key string) (*DataEntity, bool) {
    // 1. 从数据字典获取
    raw, exists := db.data.Get(key)
    if !exists {
        return nil, false
    }

    // 2. 检查是否过期
    if db.IsExpired(key) {
        return nil, false
    }

    // 3. 返回数据实体
    entity, ok := raw.(*DataEntity)
    if !ok {
        return nil, false
    }

    return entity, true
}
```

### 6.2.3. 关键算法描述

#### 键过期检查算法

```
算法:IsExpired(key)
输入:key
输出:是否过期

1. rawExpireTime, ok := ttlMap.Get(key)
2. if !ok { return false }  // 无过期时间
3. expireTime := rawExpireTime.(time.Time)
4. expired := time.Now().After(expireTime)
5. if expired {
6.     Remove(key)  // 删除键
7. }
8. return expired
```

#### 版本号管理算法

```
算法:addVersion(key)
用途:增加键的版本号(写操作时调用)

1. version, ok := versionMap.Get(key)
2. if !ok {
3.     versionMap.Put(key, uint64(1))
4. } else {
5.     v := version.(uint64)
6.     versionMap.Put(key, v+1)
7. }
```

#### 分片加锁算法

```
算法:RWLocks(writeKeys, readKeys)
用途:按分片顺序加锁,避免死锁

1. 计算所有涉及的分片
2. shards = make([]uint32, 0)
3. for key in writeKeys:
4.     shards = append(shards, spread(key))
5. for key in readKeys:
6.     shards = append(shards, spread(key))
7. 去重
8. 排序(按分片索引升序)
9. for shard in sorted_shards:
10.    shards[shard].Lock()  // 或RLock
```

**为什么排序**:避免死锁
```
场景:两个事务
- 事务A: 加锁分片1, 分片2
- 事务B: 加锁分片2, 分片1
结果:可能死锁

解决方案:按分片索引顺序加锁
- 事务A: 加锁分片1, 分片2
- 事务B: 加锁分片1, 分片2
结果:不会死锁
```

### 6.2.4. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|GetEntity|获取数据实体|[in]key string:键名<br>return *DataEntity:数据实体<br>return bool:是否存在|自动检查过期|
|PutEntity|写入数据实体|[in]key string:键名<br>[in]entity *DataEntity:数据实体<br>return int:是否新增(1=新增,0=更新)|触发insertCallback|
|Remove|删除键|[in]key string:键名|同时删除TTL和触发deleteCallback|
|Expire|设置过期时间|[in]key string:键名<br>[in]expireTime time.Time:过期时间|使用时间轮实现|
|Persist|取消过期|[in]key string:键名|移除TTL|
|ExpireIfNeeded|检查并删除过期键|[in]key string:键名|惰性删除|
|RWLocks|加锁|[in]writeKeys []string:写键<br>[in]readKeys []string:读键|按分片顺序加锁,避免死锁|
|RWUnLocks|解锁|[in]writeKeys []string:写键<br>[in]readKeys []string:读键|按加锁相反顺序解锁|
|addVersion|增加版本号|[in]key string:键名|写操作时调用|
|getVersion|获取版本号|[in]key string:键名<br>return uint64:版本号|WATCH机制使用|

---

## 6.3. String数据结构模块

### 6.3.1. 静态结构

**职责定义**:
- 实现字符串类型数据结构
- 支持二进制安全
- 支持整数和浮点数操作

**数据结构**:
```go
type String struct {
    value []byte  // 二进制安全
}
```

### 6.3.2. 处理流程

#### SET命令

```go
func execSet(db *DB, args [][]byte) Reply {
    key := string(args[0])
    value := args[1]

    // 解析参数
    var nx, xx bool
    var expireTime time.Time

    for i := 2; i < len(args); i++ {
        arg := strings.ToLower(string(args[i]))
        if arg == "nx" {
            nx = true
        } else if arg == "xx" {
            xx = true
        } else if arg == "ex" {
            seconds, _ := strconv.Atoi(string(args[i+1]))
            expireTime = time.Now().Add(time.Duration(seconds) * time.Second)
            i++
        } else if arg == "px" {
            milliseconds, _ := strconv.Atoi(string(args[i+1]))
            expireTime = time.Now().Add(time.Duration(milliseconds) * time.Millisecond)
            i++
        }
    }

    // 检查条件
    if nx && db.Exists(key) {
        return MakeNullReply()
    }
    if xx && !db.Exists(key) {
        return MakeNullReply()
    }

    // 设置值
    entity := &DataEntity{Data: &String{value: value}}
    db.PutEntity(key, entity)

    // 设置过期时间
    if !expireTime.IsZero() {
        db.Expire(key, expireTime)
    }

    return MakeOkReply()
}
```

#### GET命令

```go
func execGet(db *DB, args [][]byte) Reply {
    key := string(args[0])

    entity, exists := db.GetEntity(key)
    if !exists {
        return MakeNullReply()
    }

    str, ok := entity.Data.(*String)
    if !ok {
        return MakeErrReply("WRONGTYPE Operation against a key holding the wrong kind of value")
    }

    return MakeBulkReply(str.value)
}
```

#### INCR命令

```go
func execIncr(db *DB, args [][]byte) Reply {
    key := string(args[0])

    entity, exists := db.GetEntity(key)
    var oldValue int64 = 0
    if exists {
        str, ok := entity.Data.(*String)
        if !ok {
            return MakeErrReply("WRONGTYPE")
        }
        var err error
        oldValue, err = strconv.ParseInt(string(str.value), 10, 64)
        if err != nil {
            return MakeErrReply("ERR value is not an integer")
        }
    }

    // 检查溢出
    if oldValue == math.MaxInt64 {
        return MakeErrReply("ERR increment overflow")
    }

    newValue := oldValue + 1

    entity = &DataEntity{Data: &String{value: []byte(strconv.FormatInt(newValue, 10))}}
    db.PutEntity(key, entity)

    return MakeIntReply(newValue)
}
```

### 6.3.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execSet|设置键值|args: key, value, [NX/XX], [EX seconds/PX milliseconds]|支持多种参数组合|
|execGet|获取键值|args: key|返回值或nil|
|execIncr|原子递增|args: key|值必须为整数,范围-2^63到2^63-1|
|execIncrBy|原子递增指定值|args: key, increment|increment为64位有符号整数|
|execIncrByFloat|原子递增浮点数|args: key, increment|increment为双精度浮点数|
|execDecr|原子递减|args: key|值必须为整数|
|execDecrBy|原子递减指定值|args: key, decrement|decrement为64位有符号整数|
|execAppend|追加字符串|args: key, value|若key不存在,等同于SET|
|execStrlen|获取字符串长度|args: key|返回字节长度|
|execGetRange|获取字符串子串|args: key, start, end|支持负索引,-1表示最后一个字符|
|execSetRange|设置字符串子串|args: key, offset, value|offset必须非负|
|execMSet|批量设置|args: key1, value1, key2, value2, ...|原子操作|
|execMGet|批量获取|args: key1, key2, ...|不存在的键返回nil|

---

## 6.4. List数据结构模块

### 6.4.1. 静态结构

**职责定义**:
- 实现列表类型数据结构
- 支持双向操作(左/右)
- 根据大小自动切换编码

**数据结构**:
```go
// 小数据量: ziplist
type Ziplist struct {
    bytes []byte
    entries int
}

// 大数据量: linkedlist
type LinkedList struct {
    head *listNode
    tail *listNode
    length int
}

type List struct {
    // 根据大小自动切换
    data interface{}  // *Ziplist 或 *LinkedList
}
```

### 6.4.2. 处理流程

#### LPUSH命令

```go
func execLPush(db *DB, args [][]byte) Reply {
    key := string(args[0])
    values := args[1:]

    entity, exists := db.GetEntity(key)
    var list *List
    if !exists {
        list = &List{data: &Ziplist{}}
        entity = &DataEntity{Data: list}
        db.PutEntity(key, entity)
    } else {
        var ok bool
        list, ok = entity.Data.(*List)
        if !ok {
            return MakeErrReply("WRONGTYPE")
        }
    }

    // 插入值
    for _, value := range values {
        list.lpush(value)
    }

    // 检查是否需要切换编码
    list.checkEncode()

    return MakeIntReply(list.length())
}
```

#### LRANGE命令

```go
func execLRange(db *DB, args [][]byte) Reply {
    key := string(args[0])
    start, _ := strconv.Atoi(string(args[1]))
    stop, _ := strconv.Atoi(string(args[2]))

    entity, exists := db.GetEntity(key)
    if !exists {
        return MakeEmptyMultiBulkReply()
    }

    list, ok := entity.Data.(*List)
    if !ok {
        return MakeErrReply("WRONGTYPE")
    }

    // 处理负索引
    length := list.length()
    if start < 0 {
        start += length
    }
    if stop < 0 {
        stop += length
    }

    // 边界检查
    if start < 0 {
        start = 0
    }
    if stop >= length {
        stop = length - 1
    }

    // 获取范围
    values := list.range(start, stop)
    return MakeMultiBulkReply(values)
}
```

### 6.4.3. 编码切换

```
Ziplist -> LinkedList 切换条件:
1. 列表长度 >= 512
2. 或任意元素长度 >= 64 字节

切换流程:
1. 创建新的LinkedList
2. 遍历Ziplist所有元素
3. 逐个插入到LinkedList
4. 替换data字段
```

### 6.4.4. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execLPush|左侧插入|args: key, value1, value2, ...|返回列表长度|
|execRPush|右侧插入|args: key, value1, value2, ...|返回列表长度|
|execLPop|左侧弹出|args: key, [count]|返回弹出的元素列表|
|execRPop|右侧弹出|args: key, [count]|返回弹出的元素列表|
|execLLen|获取列表长度|args: key|返回长度|
|execLIndex|获取指定索引元素|args: key, index|支持负索引|
|execLRange|获取范围元素|args: key, start, stop|支持负索引|
|execLTrim|裁剪列表|args: key, start, stop|保留指定范围|
|execBLPop|阻塞左侧弹出|args: key1, key2, ..., timeout|阻塞直到有元素或超时|
|execBRPop|阻塞右侧弹出|args: key1, key2, ..., timeout|阻塞直到有元素或超时|

---

## 6.5. Set数据结构模块

### 6.5.1. 静态结构

**职责定义**:
- 实现集合类型数据结构
- 自动去重
- 支持集合运算
- 根据类型自动切换编码

**数据结构**:
```go
// 纯整数: intset
type Intset struct {
    contents []uint64
    encoding uint8  // int8/int16/int32/int64
    length int16
}

// 混合类型: hashtable
type HashSet struct {
    m map[string]struct{}
}

type Set struct {
    data interface{}  // *Intset 或 *HashSet
}
```

### 6.5.2. 处理流程

#### SADD命令

```go
func execSAdd(db *DB, args [][]byte) Reply {
    key := string(args[0])
    members := args[1:]

    entity, exists := db.GetEntity(key)
    var set *Set
    if !exists {
        set = &Set{data: &Intset{}}
        entity = &DataEntity{Data: set}
        db.PutEntity(key, entity)
    } else {
        var ok bool
        set, ok = entity.Data.(*Set)
        if !ok {
            return MakeErrReply("WRONGTYPE")
        }
    }

    // 添加成员
    added := 0
    for _, member := range members {
        if set.add(member) {
            added++
        }
    }

    // 检查是否需要切换编码
    set.checkEncode()

    return MakeIntReply(added)
}
```

#### SINTER命令

```go
func execSInter(db *DB, args [][]byte) Reply {
    keys := make([]string, len(args))
    for i, arg := range args {
        keys[i] = string(arg)
    }

    // 获取第一个集合
    entity, exists := db.GetEntity(keys[0])
    if !exists {
        return MakeEmptyMultiBulkReply()
    }
    set1, ok := entity.Data.(*Set)
    if !ok {
        return MakeErrReply("WRONGTYPE")
    }

    // 计算交集
    result := set1.intersection(db, keys[1:])
    return MakeMultiBulkReply(result)
}
```

### 6.5.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execSAdd|添加成员|args: key, member1, member2, ...|返回新增成员数量|
|execSRem|删除成员|args: key, member1, member2, ...|返回删除的成员数量|
|execSIsMember|判断成员是否存在|args: key, member|返回1或0|
|execSCard|获取成员数量|args: key|返回成员数量|
|execSMembers|获取所有成员|args: key|返回所有成员列表|
|execSInter|计算交集|args: key1, key2, ...|返回交集成员列表|
|execSUnion|计算并集|args: key1, key2, ...|返回并集成员列表|
|execSDiff|计算差集|args: key1, key2, ...|返回差集成员列表|
|execSRandMember|随机获取成员|args: key, [count]|不删除成员|
|execSPop|随机弹出成员|args: key, [count]|删除成员|

---

## 6.6. Sorted Set数据结构模块

### 6.6.1. 静态结构

**职责定义**:
- 实现有序集合类型数据结构
- 每个成员关联分数
- 支持按分数排序
- 支持范围查询

**数据结构**:
```go
// 小数据量: ziplist
type Ziplist struct {
    bytes []byte  // score1, member1, score2, member2, ...
    entries int
}

// 大数据量: skiplist + hashtable
type SortedSet struct {
    dict map[string]*Element  // member -> Element
    skiplist *skiplist         // 按 score 排序
}

type Element struct {
    Member string
    Score float64
}
```

### 6.6.2. 处理流程

#### ZADD命令

```go
func execZAdd(db *DB, args [][]byte) Reply {
    key := string(args[0])

    entity, exists := db.GetEntity(key)
    var zset *SortedSet
    if !exists {
        zset = &SortedSet{
            dict: make(map[string]*Element),
            skiplist: newSkipList(),
        }
        entity = &DataEntity{Data: zset}
        db.PutEntity(key, entity)
    } else {
        var ok bool
        zset, ok = entity.Data.(*SortedSet)
        if !ok {
            return MakeErrReply("WRONGTYPE")
        }
    }

    // 解析 score-member 对
    added := 0
    for i := 1; i < len(args); i += 2 {
        score, _ := strconv.ParseFloat(string(args[i]), 64)
        member := string(args[i+1])
        if zset.Add(member, score) {
            added++
        }
    }

    return MakeIntReply(added)
}
```

#### ZRANGE命令

```go
func execZRange(db *DB, args [][]byte) Reply {
    key := string(args[0])
    start, _ := strconv.Atoi(string(args[1]))
    stop, _ := strconv.Atoi(string(args[2]))
    withScores := false

    if len(args) > 3 && strings.ToLower(string(args[3])) == "withscores" {
        withScores = true
    }

    entity, exists := db.GetEntity(key)
    if !exists {
        return MakeEmptyMultiBulkReply()
    }

    zset, ok := entity.Data.(*SortedSet)
    if !ok {
        return MakeErrReply("WRONGTYPE")
    }

    // 获取范围
    elements := zset.Range(start, stop, false, withScores)
    return MakeMultiBulkReply(elements)
}
```

### 6.6.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execZAdd|添加成员|args: key, score1, member1, score2, member2, ...|返回新增成员数量|
|execZRem|删除成员|args: key, member1, member2, ...|返回删除的成员数量|
|execZCard|获取成员数量|args: key|返回成员数量|
|execZScore|获取成员分数|args: key, member|返回分数或nil|
|execZIncrBy|原子递增分数|args: key, increment, member|increment为双精度浮点数|
|execZRange|获取范围成员(升序)|args: key, start, stop, [WITHSCORES]|支持负索引|
|execZRevRange|获取范围成员(降序)|args: key, start, stop, [WITHSCORES]|支持负索引|
|execZRangeByScore|按分数范围查询|args: key, min, max, [WITHSCORES]|支持-inf、+inf、(开区间|
|execZCount|统计分数范围成员数|args: key, min, max|返回成员数量|
|execZRank|获取排名(升序)|args: key, member|返回排名,从0开始|
|execZRevRank|获取排名(降序)|args: key, member|返回排名,从0开始|

---

## 6.7. Hash数据结构模块

### 6.7.1. 静态结构

**职责定义**:
- 实现哈希类型数据结构
- 字段-值对映射
- 适合存储对象

**数据结构**:
```go
// 小数据量: ziplist
type Ziplist struct {
    bytes []byte  // field1, value1, field2, value2, ...
    entries int
}

// 大数据量: hashtable
type HashTable struct {
    m map[string]string
}

type Hash struct {
    data interface{}  // *Ziplist 或 *HashTable
}
```

### 6.7.2. 处理流程

#### HSET命令

```go
func execHSet(db *DB, args [][]byte) Reply {
    key := string(args[0])
    field := string(args[1])
    value := args[2]

    entity, exists := db.GetEntity(key)
    var hash *Hash
    if !exists {
        hash = &Hash{data: &Ziplist{}}
        entity = &DataEntity{Data: hash}
        db.PutEntity(key, entity)
    } else {
        var ok bool
        hash, ok = entity.Data.(*Hash)
        if !ok {
            return MakeErrReply("WRONGTYPE")
        }
    }

    // 设置字段
    result := hash.set(field, value)

    // 检查是否需要切换编码
    hash.checkEncode()

    return MakeIntReply(result)
}
```

### 6.7.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execHSet|设置字段值|args: key, field, value|返回1=新增,0=更新|
|execHGet|获取字段值|args: key, field|返回值或nil|
|execHMGet|批量获取字段值|args: key, field1, field2, ...|返回值列表|
|execHGetAll|获取所有字段和值|args: key|返回字段和值交错列表|
|execHDel|删除字段|args: key, field1, field2, ...|返回删除的字段数量|
|execHExists|判断字段是否存在|args: key, field|返回1或0|
|execHIncrBy|原子递增字段值|args: key, field, increment|increment为64位有符号整数|
|execHIncrByFloat|原子递增浮点数|args: key, field, increment|increment为双精度浮点数|
|execHLen|获取字段数量|args: key|返回字段数量|
|execHKeys|获取所有字段名|args: key|返回字段名列表|
|execHVals|获取所有值|args: key|返回值列表|
|execHSetNX|仅当字段不存在时设置|args: key, field, value|返回1=成功,0=失败|

---

## 6.8. 过期与淘汰策略模块

### 6.8.1. 静态结构

**职责定义**:
- 管理键的过期时间
- 实现淘汰策略
- 内存使用控制

**数据结构**:
```go
type TTLManager struct {
    ttlMap *dict.ConcurrentDict  // key -> expirationTime
    timewheel *TimeWheel         // 时间轮
    db *DB                       // 关联数据库
}
```

### 6.8.2. 处理流程

#### EXPIRE命令

```go
func execExpire(db *DB, args [][]byte) Reply {
    key := string(args[0])
    seconds, _ := strconv.Atoi(string(args[1]))

    // 检查键是否存在
    _, exists := db.GetEntity(key)
    if !exists {
        return MakeIntReply(0)
    }

    // 设置过期时间
    expireTime := time.Now().Add(time.Duration(seconds) * time.Second)
    db.Expire(key, expireTime)

    return MakeIntReply(1)
}
```

#### TTL命令

```go
func execTTL(db *DB, args [][]byte) Reply {
    key := string(args[0])

    // 检查键是否存在
    _, exists := db.GetEntity(key)
    if !exists {
        return MakeIntReply(-2)  // 不存在
    }

    // 获取过期时间
    expireTime, ok := db.ttlMap.Get(key)
    if !ok {
        return MakeIntReply(-1)  // 永不过期
    }

    // 计算剩余秒数
    ttl := time.Until(expireTime.(time.Time))
    return MakeIntReply(int(ttl.Seconds()))
}
```

#### 内存淘汰

```go
func evictKeys(db *DB, policy string) {
    switch policy {
    case "allkeys-lru":
        evictAllKeysLRU(db)
    case "volatile-lru":
        evictVolatileLRU(db)
    case "allkeys-lfu":
        evictAllKeysLFU(db)
    case "volatile-lfu":
        evictVolatileLFU(db)
    case "allkeys-random":
        evictAllKeysRandom(db)
    case "volatile-random":
        evictVolatileRandom(db)
    case "volatile-ttl":
        evictVolatileTTL(db)
    case "allkeys-ttl":
        evictAllKeysTTL(db)
    case "noeviction":
        // 不淘汰,返回错误
    }
}
```

### 6.8.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execExpire|设置过期时间(秒)|args: key, seconds|返回1=成功,0=失败|
|execPExpire|设置过期时间(毫秒)|args: key, milliseconds|返回1=成功,0=失败|
|execExpireAt|设置过期时间戳(秒)|args: key, timestamp|返回1=成功,0=失败|
|execPExpireAt|设置过期时间戳(毫秒)|args: key, timestamp-ms|返回1=成功,0=失败|
|execTTL|获取剩余秒数|args: key|返回-2=不存在,-1=永不过期|
|execPTTL|获取剩余毫秒数|args: key|返回-2=不存在,-1=永不过期|
|execPersist|取消过期时间|args: key|返回1=成功,0=失败|

---

## 6.9. 事务模块

### 6.9.1. 静态结构

**职责定义**:
- 实现MULTI/EXEC事务
- 实现WATCH乐观锁
- 保证原子性和隔离性

**数据结构**:
```go
type MultiState struct {
    inMulti bool
    queue []CmdLine  // 命令队列
    watching map[string]uint64  // key -> version
}
```

### 6.9.2. 处理流程

#### MULTI命令

```go
func startMulti(c Connection) Reply {
    if c.InMultiState() {
        return MakeErrReply("ERR MULTI calls can not be nested")
    }

    c.SetMultiState(true)
    c.ClearCmdQueue()

    return MakeOkReply()
}
```

#### EXEC命令

```go
func execExec(db *DB, c Connection) Reply {
    if !c.InMultiState() {
        return MakeErrReply("ERR EXEC without MULTI")
    }

    // 获取命令队列
    cmdLines := c.GetCmdQueue()
    if len(cmdLines) == 0 {
        return MakeEmptyMultiBulkReply()
    }

    // 提取读写键
    var writeKeys, readKeys []string
    for _, cmdLine := range cmdLines {
        cmdName := strings.ToLower(string(cmdLine[0]))
        cmd, ok := cmdTable[cmdName]
        if !ok {
            continue
        }
        wk, rk := cmd.prepare(cmdLine[1:])
        writeKeys = append(writeKeys, wk...)
        readKeys = append(readKeys, rk...)
    }

    // 加锁
    db.RWLocks(writeKeys, readKeys)
    defer db.RWUnLocks(writeKeys, readKeys)

    // 检查WATCH
    if db.checkWatching(c) {
        // 版本变化,事务中止
        c.ClearWatching()
        c.SetMultiState(false)
        return MakeNullReply()
    }

    // 执行命令
    results := make([]Reply, len(cmdLines))
    for i, cmdLine := range cmdLines {
        cmdName := strings.ToLower(string(cmdLine[0]))
        cmd, ok := cmdTable[cmdName]
        if !ok {
            results[i] = MakeErrReply("ERR unknown command")
            continue
        }
        results[i] = cmd.executor(db, cmdLine[1:])
    }

    // 清理状态
    c.ClearWatching()
    c.SetMultiState(false)

    return MakeMultiBulkReply(results)
}
```

#### WATCH命令

```go
func execWatch(db *DB, c Connection, args [][]byte) Reply {
    for _, arg := range args {
        key := string(arg)
        version := db.getVersion(key)
        c.AddWatching(key, version)
    }

    return MakeOkReply()
}
```

### 6.9.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|startMulti|标记事务开始|-|设置MULTI状态|
|execExec|执行事务|-|返回命令结果数组或nil(失败)|
|execDiscard|取消事务|-|清空命令队列|
|execWatch|监视键|args: key1, key2, ...|记录键版本号|
|execUnwatch|取消监视|-|清空watching|

---

## 6.10. 持久化模块 (aof)

### 6.10.1. 静态结构

**职责定义**:
- AOF文件写入
- AOF重写
- RDB生成和加载

**数据结构**:
```go
type Persister struct {
    db *DB
    aofFile *os.File
    aofChan chan *payload
    aofFsync string  // always/everysec/no
    tmpFile *os.File  // 重写时临时文件
    rewriteBuffer []CmdLine  // 重写期间的新命令
    pausingAof sync.Mutex  // 重写时暂停AOF
}
```

### 6.10.2. 处理流程

#### AOF写入流程

```go
func (p *Persister) SaveCmdLine(dbIndex int, cmdLine CmdLine) {
    payload := &payload{
        cmdLine: cmdLine,
        dbIndex: dbIndex,
    }
    p.aofChan <- payload  // 异步写入
}

func (p *Persister) listenCmd() {
    for {
        select {
        case payload := <-p.aofChan:
            p.writeAof(payload)
        }
    }
}

func (p *Persister) writeAof(payload *payload) {
    // 检查是否需要SELECT
    if payload.dbIndex != p.currentDB {
        p.writeString("*2\r\n$6\r\nSELECT\r\n$")
        p.writeString(strconv.Itoa(payload.dbIndex))
        p.writeString("\r\n")
        p.currentDB = payload.dbIndex
    }

    // 序列化为RESP
    data := toRESP(payload.cmdLine)
    p.aofFile.Write(data)

    // Fsync
    if p.aofFsync == "always" {
        p.aofFile.Sync()
    }
}
```

#### AOF重写流程

```go
func (p *Persister) Rewrite() error {
    // 1. 暂停AOF
    p.pausingAof.Lock()
    defer p.pausingAof.Unlock()

    // 2. 创建临时文件
    tmpFile, err := os.CreateTemp("", "aof-rewrite-*.aof")
    if err != nil {
        return err
    }

    // 3. 写入RDB前缀
    err = p.generateRDB(tmpFile)
    if err != nil {
        return err
    }

    // 4. 重放rewrite buffer
    for _, cmdLine := range p.rewriteBuffer {
        data := toRESP(cmdLine)
        tmpFile.Write(data)
    }

    // 5. 原子替换
    tmpFile.Close()
    os.Rename(tmpFile.Name(), p.aofFile.Name())

    // 6. 重新打开文件
    p.aofFile, _ = os.OpenFile(p.aofFile.Name(), os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)

    // 7. 清空buffer
    p.rewriteBuffer = nil

    return nil
}
```

### 6.10.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|NewPersister|创建持久化器|db *DB, filename string, load bool, fsync string<br>return *Persister, error|load=true时加载AOF|
|SaveCmdLine|保存命令|dbIndex int, cmdLine CmdLine|异步写入AOF|
|LoadAof|加载AOF|maxBytes int|最多加载字节数|
|Rewrite|重写AOF|-|阻塞式重写|
|Fsync|强制刷盘|-|立即fsync|
|Close|关闭持久化器|-|优雅关闭|

---

## 6.11. 主从复制模块

### 6.11.1. 静态结构

**职责定义**:
- 主节点:处理写操作,复制数据到从节点
- 从节点:接收复制,只读服务

**数据结构**:
```go
type MasterStatus struct {
    replicas []*replica
    offset int64
}

type replica struct {
    conn Connection
    offset int64
}

type SlaveStatus struct {
    masterHost string
    masterPort int
    offset int64
}
```

### 6.11.2. 处理流程

#### SYNC命令(全量同步)

```go
func execSync(c Connection, server *Server) Reply {
    // 1. 生成RDB
    rdbData := server.generateRDB()

    // 2. 发送RDB
    c.Send(rdbData)

    // 3. 发送后续AOF
    // ...

    return MakeOkReply()
}
```

#### PSYNC命令(增量同步)

```go
func execPSync(c Connection, server *Server, args [][]byte) Reply {
    replicationID := string(args[0])
    offset, _ := strconv.ParseInt(string(args[1]), 10, 64)

    // 检查是否可以增量同步
    if server.canPartialSync(replicationID, offset) {
        // 增量同步
        data := server.getAOFAfter(offset)
        c.Send(data)
        return MakeOkReply()
    }

    // 全量同步
    return execSync(c, server)
}
```

### 6.11.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execSlaveOf|设置主节点|args: masterHost, masterPort|建立复制关系|
|execSync|全量同步|-|从节点发起|
|execPSync|增量同步|args: replicationID, offset|从节点发起|

---

## 6.12. 安全模块

### 6.12.1. 静态结构

**职责定义**:
- 密码认证
- IP白名单
- 命令重命名和禁用

### 6.12.2. 处理流程

#### AUTH命令

```go
func execAuth(c Connection, server *Server, args [][]byte) Reply {
    if !config.Properties.RequirePass {
        return MakeErrReply("ERR AUTH failed")
    }

    password := string(args[0])
    if password != config.Properties.RequirePass {
        return MakeErrReply("ERR invalid password")
    }

    c.SetAuthenticated()
    return MakeOkReply()
}
```

### 6.12.3. 函数列表

|函数名|函数功能|参数及返回值|说明|
|---|---|---|---|
|execAuth|密码认证|args: password|验证密码|
|checkIPWhitelist|检查IP白名单|ip string|返回是否允许|

---

# 7. 完成设计 checklist 自检

|检查项|状态|
|---|---|
|需求跟踪表完整|✓|
|模块整体目标明确|✓|
|对外接口清晰|✓|
|静态结构完整|✓|
|流程图清晰|✓|
|数据结构定义完整|✓|
|函数列表完整|✓|
|风险分析充分|✓|
|可测试性设计|✓|
|可扩展性设计|✓|
|安全性设计|✓|
|可靠性设计|✓|

---

# 8. 总结

## 8.1. 关联分析

**对现有系统的影响**:
- GoCache 是独立系统,可单独部署
- 协议兼容RESP,现有客户端可直接连接
- 支持主从复制,可作为其他系统的缓存层

**优势**:
- Go 语言实现,代码清晰易维护
- 分片锁+协程模型,充分利用多核
- 模块化设计,便于扩展和维护
- 支持多种持久化策略,数据安全可靠

**劣势**:
- 性能略逊于 C 实现(Redis)
- 生态不如 Redis 成熟
- 部分高级特性未实现(如集群、Lua脚本)

## 8.2. 遗留问题解决

1. **集群模式**:当前仅支持单机+主从,集群模式作为后续扩展
2. **Lua 脚本**:暂未支持 Lua 脚本执行
3. **Stream 数据结构**:未实现 Stream 数据结构
4. **模块系统**:未实现动态加载机制

**解决方案**:
- 集群模式:预留接口,后续实现基于Raft的分布式一致性
- Lua 脚本:集成 Go Lua 解释器
- Stream:基于 List 和 Hash 实现
- 模块系统:设计插件化架构

---

# 9. 业务逻辑相关的测试用例

## 9.1. 基础命令测试

### SET/GET 测试

```
测试步骤:
1. 连接 GoCache 服务器
2. 发送命令: SET test_key "test_value"
3. 验证返回: +OK
4. 发送命令: GET test_key
5. 验证返回: $10 "test_value"

预期结果:命令执行成功,值正确返回
```

### EXPIRE/TTL 测试

```
测试步骤:
1. SET key1 value1 EX 2  (设置2秒过期)
2. GET key1  (立即查询)
3. 验证返回: value1
4. TTL key1
5. 验证返回: 2 或 1
6. 等待 3 秒
7. GET key1
8. 验证返回: nil

预期结果:键自动过期
```

## 9.2. 事务测试

### MULTI/EXEC 测试

```
测试步骤:
1. MULTI
2. SET k1 v1
3. GET k1
4. EXEC
5. 验证返回: +OK, v1

预期结果:事务原子执行
```

### WATCH 测试

```
测试步骤:
1. 客户端1: WATCH balance
2. 客户端1: MULTI
3. 客户端1: GET balance
4. 客户端2: SET balance 200  (修改)
5. 客户端1: EXEC
6. 验证返回: nil (事务中止)

预期结果:WATCH 检测到修改,事务中止
```

## 9.3. 持久化测试

### AOF 测试

```
测试步骤:
1. 启用 AOF: appendonly yes
2. SET key1 value1
3. 重启服务器
4. GET key1
5. 验证返回: value1

预期结果:数据从 AOF 恢复
```

### AOF 重写测试

```
测试步骤:
1. 写入 10000 个键
2. BGREWRITEAOF
3. 等待重写完成
4. 检查 appendonly.aof 文件大小
5. 验证:重写后文件显著变小
6. 重启服务器
7. 随机查询部分键

预期结果:重写成功,数据完整
```

## 9.4. 性能测试

### QPS 测试

```
测试工具:自定义压测工具
测试参数:50并发客户端,SET/GET操作

预期结果:
- QPS ≥ 100,000
- P99延迟 < 1ms
- 无错误
```

### 并发测试

```
测试工具:自定义压测工具
测试参数:10,000并发连接

预期结果:
- 所有连接成功
- 无连接泄露
- 内存使用稳定
```

---

# 10. 变更控制

### 10.1. 变更列表

|变更章节|变更内容|变更原因|变更对老功能、原有设计的影响|
|---|---|---|---|
|无|-|-|-|

---

*文档版本:1.0*
*编写日期:2026-01-10*
