# 高性能内存缓存系统需求文档

## 1. 项目背景与问题分析

### 1.1 现状与挑战

在现代互联网应用架构中，随着用户量的增长和业务复杂度的提升，开发团队面临着以下核心痛点：

#### 1.1.1 数据访问性能瓶颈
**问题描述：**
- 传统关系型数据库基于磁盘存储，在高并发场景下I/O延迟成为系统瓶颈
- 每次数据访问都需要经历SQL解析、执行计划优化、磁盘读取等流程
- 数据库连接池在高并发下容易耗尽，导致请求排队甚至超时
- 复杂查询（如多表关联、排序聚合）进一步放大性能问题

**实际影响：**
- 页面响应时间慢，用户体验差
- 数据库CPU负载高，硬件成本上升
- 系统吞吐量受限，无法支撑业务增长

#### 1.1.2 零信任架构下的动态访问控制需求
**问题描述：**
- 零信任架构要求"永不信任，始终验证"，每次访问都需要实时决策
- 设备信任评分需要综合历史行为、威胁情报、地理位置等多维数据
- 用户、设备、环境的组合策略计算复杂，传统数据库无法满足毫秒级响应要求
- 多因素认证（MFA）过程中验证码、推送状态需要临时存储和快速校验

**传统方案的缺陷：**
- 数据库查询设备信息和历史行为：响应时间>100ms，用户体验差
- 本地缓存无法在分布式网关间共享，导致重复计算
- 缺乏统一的短期凭证管理，各系统自行实现，安全风险高
- ACL规则的实时计算需要频繁访问策略库，数据库成为瓶颈

**实际影响：**
- 用户访问延迟高，每次请求都需要等待多次权限验证
- 高并发场景下授权服务压力巨大，成为性能瓶颈
- 动态策略更新后无法快速生效，影响安全响应速度
- 异常访问行为检测滞后，无法实时阻断风险

#### 1.1.3 复杂数据结构支持实时风控与审计
**问题描述：**
- 风控系统需要实时统计用户在时间窗口内的访问频率（滑动窗口计数）
- 威胁情报检测需要快速判断IP或设备ID是否在黑名单中（集合运算）
- 审计日志的实时分析需要提取Top N异常用户（排序和聚合）
- 微服务架构下的服务网格需要缓存短生命周期证书和元数据
- 分布式限流需要在多个网关实例间同步计数器状态

**传统方案的局限：**
- 简单的Key-Value缓存无法支持复杂查询（如时间窗口统计、范围查询）
- 在应用层实现滑动窗口、漏桶等算法，代码复杂且性能差
- 缺乏原子操作保证，分布式限流场景下计数不准确
- 黑名单、灰名单的集合运算需要多次网络往返，延迟高
- 服务间证书轮换后，缓存更新不及时导致连接失败

#### 1.1.4 安全敏感数据的生命周期管理
**问题描述：**
- 零信任网络访问（ZTNA）中的短期令牌、会话凭证需要快速过期和清理
- 多因素认证的验证码、推送确认状态通常只有几分钟有效期
- 设备信任评分和风险等级需要定期更新，避免使用过时数据
- 威胁情报的黑名单、灰名单需要动态加载和实时生效
- 密钥、证书等敏感信息不应长期驻留在内存中

**安全风险：**
- 应用本地缓存的敏感数据（如令牌）进程重启后可能残留在内存 dump 中
- 缺乏统一的过期策略，导致临时凭证未及时清理，增加攻击面
- 多实例缓存不一致，可能导致撤销的令牌在某些实例上仍然有效
- 缓存穿透、雪崩等问题可能被攻击者利用进行DoS攻击
- 敏感数据长期驻留内存，增加内存泄露风险

**开发团队痛点：**
- 安全策略与业务代码耦合，难以统一更新和审计
- 不同安全组件使用不同的缓存实现，缺乏统一的密钥管理
- 缓存相关的安全漏洞难以排查（如过期时间配置不当）

### 1.2 解决方案定位

基于以上痛点，我们需要构建一个**高性能内存缓存系统**，其核心定位：

1. **极致性能**：基于内存存储，提供微秒级的读写响应，满足零信任架构的实时验证需求
2. **丰富数据结构**：支持多种数据类型，满足风控、审计、策略决策等复杂场景
3. **自动过期管理**：精确的TTL控制，确保敏感数据的生命周期安全
4. **原子操作保证**：分布式限流、计数器等场景的数据一致性
5. **可靠稳定**：提供持久化、主从复制等高可用机制，保障安全策略服务不中断

---

## 2. 系统需求定义

### 2.1 功能性需求

#### 2.1.1 基础数据操作（String类型）
**需求描述：** 提供基础键值存储能力

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| SET | SET key value [EX seconds \| PX milliseconds] | OK | O(1) | 值最大512MB |
| GET | GET key | 值或nil | O(1) | - |
| DEL | DEL key [key ...] | 删除的键数量 | O(N) | N为键数量 |
| EXISTS | EXISTS key [key ...] | 存在的键数量 | O(N) | - |
| EXPIRE | EXPIRE key seconds | 1=成功, 0=失败 | O(1) | 最大秒数: 2^63-1 |
| TTL | TTL key | 剩余秒数(-1=永不过期, -2=不存在) | O(1) | - |
| PEXPIRE | PEXPIRE key milliseconds | 1=成功, 0=失败 | O(1) | 最大毫秒数: 2^63-1 |
| PTTL | PTTL key | 剩余毫秒数 | O(1) | - |

**规格基线：**
- **键名长度限制**：最大512MB
- **键值大小限制**：最大512MB
- **键数量限制**：单实例最多2^32-1个键（约43亿）
- **过期时间精度**：毫秒级（PX/PEXPIRE命令）
- **内存对齐**：键值对存储使用SDS结构，带长度前缀，二进制安全
- **批量操作支持**：DEL、EXISTS支持多键操作，减少网络往返

**使用场景：**
- 设备信任评分缓存（设备ID -> 信任分数、风险等级）
- 用户策略缓存（用户ID + 设备ID -> 访问策略JSON）
- 威胁情报缓存（IP/域名 -> 威胁等级、情报来源）

#### 2.1.2 字符串类型增强功能
**需求描述：** 在基础键值对之上，提供字符串类型的增强操作

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| INCR | INCR key | 递增后的值 | O(1) | 值必须为整数，范围: [-(2^63), 2^63-1] |
| INCRBY | INCRBY key increment | 递增后的值 | O(1) | increment为64位有符号整数 |
| DECR | DECR key | 递减后的值 | O(1) | 值必须为整数 |
| DECRBY | DECRBY key decrement | 递减后的值 | O(1) | decrement为64位有符号整数 |
| APPEND | APPEND key value | 追加后的字符串长度 | O(1) | 若key不存在，等同于SET |
| STRLEN | STRLEN key | 字符串长度 | O(1) | - |
| GETRANGE | GETRANGE key start end | 子串 | O(1) | 支持负索引，-1表示最后一个字符 |
| MSET | MSET key1 value1 [key2 value2 ...] | OK | O(N) | N为键值对数量，原子操作 |
| MGET | MGET key1 [key2 ...] | 值列表 | O(N) | N为键数量 |

**规格基线：**
- **整数范围**：64位有符号整数 [-(2^63), 2^63-1]
- **原子性保证**：INCR系列命令为原子操作，无竞态条件
- **批量操作上限**：MSET/MGET建议单次不超过100个键
- **数值溢出处理**：超出范围返回错误，不会回绕

**使用场景：**
- 用户访问频率计数（用于风控限流，如每分钟限制100次请求）
- 分布式环境下的唯一请求ID生成（用于审计追踪）
- 设备异常行为计数（如连续认证失败次数）

#### 2.1.3 列表类型
**需求描述：** 提供有序、可重复的元素集合，支持双向操作

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| LPUSH | LPUSH key value [value ...] | 列表长度 | O(1) | 可插入多个值 |
| RPUSH | RPUSH key value [value ...] | 列表长度 | O(1) | 可插入多个值 |
| LPOP | LPOP key [count] | 弹出的元素列表 | O(1) | count可选，批量弹出 |
| RPOP | RPOP key [count] | 弹出的元素列表 | O(1) | count可选，批量弹出 |
| LLEN | LLEN key | 列表长度 | O(1) | - |
| LINDEX | LINDEX key index | 指定索引的元素 | O(N) | N为索引位置，支持负索引 |
| LRANGE | LRANGE key start stop | 元素列表 | O(S+N) | S为start偏移，N为范围长度 |
| LTRIM | LTRIM key start stop | OK | O(N) | N为被删除元素数量 |

**规格基线：**
- **元素数量限制**：单个列表最多2^32-1个元素（约43亿）
- **元素大小限制**：每个元素最大512MB
- **索引范围**：支持负索引，-1表示最后一个元素
- **底层实现**：双向链表

**使用场景：**
- 安全事件队列（IDS/IPS告警从左侧推入，SOC分析从右侧弹出）
- 用户访问轨迹时间线（最新访问记录在左侧，支持回溯分析）
- 审计日志缓冲（临时存储日志批量写入数据库）

#### 2.1.4 集合类型
**需求描述：** 提供无序、唯一的元素集合，支持集合运算

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| SADD | SADD key member [member ...] | 新增成员数量 | O(N) | N为成员数量，自动去重 |
| SREM | SREM key member [member ...] | 删除的成员数量 | O(N) | N为成员数量 |
| SISMEMBER | SISMEMBER key member | 1=存在, 0=不存在 | O(1) | - |
| SCARD | SCARD key | 集合成员数量 | O(1) | - |
| SMEMBERS | SMEMBERS key | 所有成员列表 | O(N) | N为集合大小 |
| SINTER | SINTER key [key ...] | 交集成员列表 | O(N*M) | N为最小集合大小，M为集合数量 |
| SUNION | SUNION key [key ...] | 并集成员列表 | O(N) | N为所有集合大小之和 |
| SDIFF | SDIFF key [key ...] | 差集成员列表 | O(N) | N为所有集合大小之和 |
| SRANDMEMBER | SRANDMEMBER key [count] | 随机成员列表 | O(N) | count可选，不删除成员 |
| SPOP | SPOP key [count] | 随机弹出的成员 | O(N) | count可选，删除成员 |

**规格基线：**
- **元素数量限制**：单个集合最多2^32-1个成员（约43亿）
- **元素大小限制**：每个成员最大512MB
- **集合运算上限**：建议SINTER/SUNION/SDIFF操作的集合数量不超过10个
- **底层实现**：哈希表（map）

**使用场景：**
- 黑名单管理（恶意IP集合、恶意设备ID集合）
- 用户权限集合（用户ID -> 拥有的权限标签集合）
- 威胁情报关联（攻击者IP集合 ∩ 受害者IP集合，找出共同IP）
- 角色继承（子角色权限集合 ⊆ 父角色权限集合）

#### 2.1.5 有序集合类型
**需求描述：** 提供有序、唯一的元素集合，每个元素关联分数

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| ZADD | ZADD key score member [score member ...] | 新增成员数量 | O(M*log(N)) | M为成员数量，N为集合大小 |
| ZREM | ZREM key member [member ...] | 删除的成员数量 | O(M*log(N)) | M为成员数量 |
| ZCARD | ZCARD key | 集合成员数量 | O(1) | - |
| ZSCORE | ZSCORE key member | 分数（nil=不存在） | O(1) | - |
| ZINCRBY | ZINCRBY key increment member | 新分数 | O(log(N)) | increment为双精度浮点数 |
| ZRANGE | ZRANGE key start stop [WITHSCORES] | 成员列表 | O(log(N)+M) | M为返回成员数量，支持负索引 |
| ZREVRANGE | ZREVRANGE key start stop [WITHSCORES] | 成员列表（降序） | O(log(N)+M) | M为返回成员数量 |
| ZRANGEBYSCORE | ZRANGEBYSCORE key min max [WITHSCORES] | 成员列表 | O(log(N)+M) | 支持-inf、+inf、(符号开区间 |
| ZCOUNT | ZCOUNT key min max | 分数范围内的成员数 | O(log(N)) | - |
| ZRANK | ZRANK key member | 排名（从0开始） | O(log(N)) | nil=不存在 |
| ZREVRANK | ZREVRANK key member | 降序排名 | O(log(N)) | nil=不存在 |

**规格基线：**
- **元素数量限制**：单个有序集合最多2^32-1个成员（约43亿）
- **分数范围**：双精度浮点数，范围 -17亿 < score < 17亿
- **元素大小限制**：每个成员最大512MB
- **底层实现**：slice + map 组合（切片保持排序，哈希表提供O(1)查找）

**使用场景：**
- 实时风险排行榜（用户风险分数排行，Top 100高风险用户）
- 设备信任评分排序（按信任分数倒序，快速筛选低信任设备）
- 时间窗口限流（使用时间戳作为分数，快速清理过期记录）
- 异常行为统计（按访问频率排序，识别异常用户）

#### 2.1.6 哈希类型
**需求描述：** 提供字段-值对的映射表，适合存储对象

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| HSET | HSET key field value | 1=新增, 0=更新 | O(1) | 单个字段 |
| HMSET | HMSET key field1 value1 [field2 value2 ...] | OK | O(N) | N为字段数量 |
| HGET | HGET key field | 值或nil | O(1) | - |
| HMGET | HMGET key field1 [field2 ...] | 值列表 | O(N) | N为字段数量 |
| HGETALL | HGETALL key | 所有字段和值 | O(N) | N为哈希表大小 |
| HDEL | HDEL key field [field ...] | 删除的字段数量 | O(N) | N为字段数量 |
| HEXISTS | HEXISTS key field | 1=存在, 0=不存在 | O(1) | - |
| HINCRBY | HINCRBY key field increment | 递增后的值 | O(1) | increment为64位有符号整数 |
| HLEN | HLEN key | 字段数量 | O(1) | - |
| HKEYS | HKEYS key | 所有字段名 | O(N) | N为哈希表大小 |
| HVALS | HVALS key | 所有值 | O(N) | N为哈希表大小 |
| HSETNX | HSETNX key field value | 1=成功, 0=失败 | O(1) | 仅当字段不存在时设置 |

**规格基线：**
- **字段数量限制**：单个哈希最多2^32-1个字段（约43亿）
- **字段名长度限制**：每个字段名最大512MB
- **字段值大小限制**：每个字段值最大512MB
- **底层实现**：哈希表（map）

**使用场景：**
- 设备属性存储（设备ID -> {类型, OS版本, 位置, 信任分数}）
- 用户会话信息（会话ID -> {用户ID, 登录时间, 设备指纹, IP}）
- 访问策略规则（策略ID -> {资源, 动作, 条件, 优先级}）
- 风控规则配置（规则ID -> {阈值, 时间窗口, 处置动作}）

#### 2.1.7 过期与淘汰策略
**需求描述：** 自动管理数据生命周期，防止内存无限增长

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| EXPIRE | EXPIRE key seconds | 1=成功, 0=失败 | O(1) | 覆盖已有过期时间 |
| PEXPIRE | PEXPIRE key milliseconds | 1=成功, 0=失败 | O(1) | 毫秒级精度 |
| EXPIREAT | EXPIREAT key timestamp | 1=成功, 0=失败 | O(1) | timestamp为Unix秒数 |
| PEXPIREAT | PEXPIREAT key timestamp-ms | 1=成功, 0=失败 | O(1) | timestamp-ms为Unix毫秒数 |
| TTL | TTL key | 剩余秒数 | O(1) | -2=不存在, -1=永不过期 |
| PTTL | PTTL key | 剩余毫秒数 | O(1) | -2=不存在, -1=永不过期 |
| PERSIST | PERSIST key | 1=成功, 0=失败 | O(1) | 移除过期时间 |

**规格基线：**
- **过期时间精度**：毫秒级（PEXPIRE、PEXPIREAT）
- **过期时间范围**：0 到 2^63-1（约2920亿年）
- **删除策略**：
  - **惰性删除**：访问键时检查过期，已过期则删除
  - **时间轮主动删除**：使用分层时间轮，10ms间隔，1024个桶，自动触发过期回调
- **内存淘汰策略**（maxmemory限制触发时）：
  - **noeviction**：不淘汰，写操作返回错误（默认）
  - **allkeys-lru**：淘汰所有键的LRU
  - **volatile-lru**：仅淘汰设置了TTL的键的LRU
  - **allkeys-lfu**：淘汰所有键的LFU
  - **volatile-lfu**：仅淘汰设置了TTL的键的LFU
  - **allkeys-random**：随机淘汰所有键
  - **volatile-random**：随机淘汰设置了TTL的键
  - **volatile-ttl**：淘汰即将过期的键

**使用场景：**
- 一次性凭证存储（MFA验证码、邮件链接，5分钟过期）
- 短期访问令牌（ZTNA临时访问令牌，1小时过期）
- 会话超时管理（用户30分钟无活动自动下线）
- 威胁情报时效性（临时封禁IP，24小时自动解封）

#### 2.1.8 事务功能
**需求描述：** 保证一组操作的原子性执行

**命令规格：**

| 命令 | 语法 | 返回值 | 时间复杂度 | 规格 |
|------|------|--------|------------|------|
| MULTI | MULTI | OK | O(1) | 标记事务开始 |
| EXEC | EXEC | 命令返回值数组 | O(N) | N为事务中的命令数量 |
| DISCARD | DISCARD | OK | O(1) | 取消事务 |
| WATCH | WATCH key [key ...] | OK | O(1) | 乐观锁，监视键 |
| UNWATCH | UNWATCH | OK | O(1) | 取消所有监视 |

**规格基线：**
- **事务隔离级别**：EXEC执行期间，不执行其他客户端的命令
- **原子性保证**：事务中的命令按顺序执行，中间不会插入其他命令
- **错误处理**：
  - 入队时语法错误：EXEC返回nil，所有命令不执行
  - 执行时运行时错误：已执行的命令不回滚，后续命令继续执行
- **乐观锁机制**：
  - WATCH监视的键被其他客户端修改，EXEC执行失败
  - EXEC失败后需重新执行MULTI开始新事务
- **命令数量限制**：单个事务建议不超过100个命令

**使用场景：**
- 分布式限流（检查计数器、递增计数器、返回结果，原子执行）
- 设备信任评分更新（读取当前分数、计算新分数、写入，原子执行）
- 会话状态转移（删除旧会话、创建新会话、更新在线用户数，原子执行）
- 风控规则触发（检查条件、记录事件、更新黑名单，原子执行）

### 2.2 非功能性需求

#### 2.2.1 可靠性要求

**需求背景：**
作为内存缓存系统，数据存储在内存中，存在以下风险：
- 进程崩溃或重启导致数据全部丢失
- 单点故障导致服务不可用
- 硬件故障导致数据无法恢复

为保障生产环境的稳定运行，必须提供数据持久化和高可用机制。

**持久化能力：**
- **RDB快照**（推荐用于备份）：
  - 定时将内存数据全量保存到磁盘
  - 支持配置保存策略（如每5分钟至少有1次写入则保存）
  - 生成紧凑的压缩文件，适合备份和恢复
- **AOF日志**（推荐用于数据安全）：
  - 记录每个写操作命令到日志文件
  - 支持多种同步策略（每秒同步、每个命令同步）
  - 重启时重放日志恢复数据
  - 支持AOF重写，压缩日志文件

**高可用能力：**
- **主从复制**：
  - 主节点处理写操作，从节点复制数据
  - 从节点可处理读操作，分担主节点压力
  - 支持全量同步（SYNC）和增量同步（PSYNC）
  - 支持复制积压缓冲区（backlog）用于部分同步

**数据恢复能力：**
- 系统故障重启后可从持久化文件恢复数据
- 支持将快照文件传输到其他服务器进行数据迁移
- AOF日志记录所有写操作，可用于审计和追溯

#### 2.2.2 性能要求

**响应时间指标：**

| 操作类型 | P50 | P95 | P99 | P99.9 | 测试条件 |
|---------|-----|-----|-----|-------|---------|
| GET/SET | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端, 值大小1KB |
| INCR/DECR | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端 |
| HGET/HSET | < 100μs | < 500μs | < 1ms | < 5ms | 单客户端, 哈希10个字段 |
| LPUSH/RPUSH | < 100μs | < 1ms | < 2ms | < 10ms | 列表长度<1000 |
| ZADD/ZRANGE | < 200μs | < 1ms | < 3ms | < 15ms | 有序集合<1万成员 |
| MGET(100键) | < 1ms | < 5ms | < 10ms | < 50ms | 批量获取100个键 |

**吞吐量指标：**

| 测试场景 | QPS目标 | 测试工具 | 测试参数 |
|---------|---------|---------|---------|
| GET/SET (50并发) | ≥ 100,000 | redis-benchmark | 单键, 值大小1KB |
| SET/GET混合 (100并发) | ≥ 80,000 | redis-benchmark | 读写比1:1 |
| MGET批量 (50并发) | ≥ 50,000 | 自定义脚本 | 每次获取100个键 |
| Pipeline (50并发) | ≥ 150,000 | 自定义脚本 | 每个Pipeline 50个命令 |

**并发能力指标：**
- **最大并发连接数**：≥ 10,000个同时连接的客户端
- **连接建立速率**：≥ 5,000个连接/秒
- **内存占用**：每个连接占用 < 10KB内存

**内存使用效率：**
- **内存碎片率**：正常范围1.0~1.5，超过1.5需告警
- **最大内存限制**：支持配置maxmemory，超出后触发淘汰策略
- **键空间压缩**：小对象（< 64字节）使用特殊编码，节省内存

**网络性能：**
- **TCP延迟**：同城机房 < 0.5ms，跨地域 < 50ms
- **带宽利用率**：千兆网卡满载时吞吐量 ≥ 800Mbps
- **大值传输**：支持最大512MB的单值传输，传输速率 ≥ 100MB/s

#### 2.2.3 可用性要求

| 可用性指标 | 目标值 | 测量方法 |
|-----------|--------|---------|
| 服务可用性（SLA） | ≥ 99.9% | (总时间-故障时间)/总时间 |
| 节点重启时间 | < 30秒 | 带持久化恢复的单节点重启 |
| 数据丢失窗口 | < 1秒 | AOF每秒同步模式下最多丢失数据量 |
| 主从复制延迟 | < 1秒 | 主节点写入到从节点同步完成的时间差 |

**故障场景应对：**
- **主节点崩溃**：从节点可提升为主节点（手动配置）
- **网络分区**：需要手动处理分区恢复
- **从节点故障**：不影响主节点服务，自动重新同步
- **磁盘满**：拒绝写入操作并触发告警，不崩溃

#### 2.2.4 扩展性要求

| 扩展类型 | 指标 | 说明 |
|---------|------|------|
| 垂直扩展 | 支持多核CPU | 充分利用16核、32核服务器 |
| 内存扩展 | 单实例最大支持TB级内存 | 受限于硬件配置 |

#### 2.2.5 兼容性要求

**协议兼容：**
- **RESP协议（RESP2/RESP3）**：文本协议，简单易解析
- **Telnet友好**：支持直接使用Telnet/Netcat进行操作
- **批量操作**：支持Pipeline模式，减少网络往返

**客户端支持：**
| 语言 | 官方/推荐客户端 | 特性 |
|------|----------------|------|
| Go | go-redis | 连接池、Pipeline、集群支持 |
| Java | lettuce/Jedis | 异步、响应式、集群支持 |
| Python | redis-py | 连接池、事务、Pub/Sub |
| C/C++ | hiredis | 高性能、异步支持 |

**平台兼容：**
- **操作系统**：Linux (推荐)、macOS、Windows
- **CPU架构**：x86_64、ARM64
- **编译器**：GCC 4.9+、Clang 3.4+、MSVC 2015+

#### 2.2.6 可维护性要求

**监控指标：**

| 监控类别 | 指标名称 | 告警阈值 | 说明 |
|---------|---------|---------|------|
| 性能 | QPS | > 80,000 | 接近性能上限 |
| 性能 | 延迟P99 | > 10ms | 性能下降 |
| 性能 | 慢查询数 | > 10/分钟 | 执行时间>10ms的查询 |
| 内存 | 内存使用率 | > 80% | 接近maxmemory限制 |
| 内存 | 内存碎片率 | > 1.5 | 需要内存整理 |
| 内存 | 键数量 | > 1000万 | 键空间过大 |
| 连接 | 客户端连接数 | > 8000 | 接近连接上限 |
| 复制 | 主从延迟 | > 5秒 | 复制延迟过高 |
| 复制 | 复制积压缓冲区 | < 1MB | 可能导致部分同步失败 |
| 持久化 | RDB保存失败 | 连续3次 | 持久化异常 |

**运维工具：**
- **命令行客户端**：支持交互式操作、批量命令执行
- **数据导入导出**：
  - RDB文件：全量数据导入导出
- **调试工具**：
  - MONITOR：实时监控所有命令（生产环境慎用）
  - SLOWLOG：慢查询日志，记录执行时间超过阈值的命令
  - INFO：查看服务器状态和统计信息

#### 2.2.7 安全性要求

**访问控制：**
| 安全特性 | 说明 | 配置示例 |
|---------|------|---------|
| 密码认证 | 客户端连接后需AUTH命令验证 | requirepass yourpassword |

**数据安全：**
- **数据脱敏**：敏感命令（如AUTH）不在日志中记录

**安全基线：**
- 默认绑定127.0.0.1，仅本地访问
- 生产环境必须设置密码（至少16字符）

---

## 3. 系统架构设计要求

### 3.1 核心架构原则
1. **内存优先**：所有数据存储在内存，磁盘仅用于持久化
2. **单线程模型**（推荐）：避免锁竞争，简化并发控制
3. **I/O多路复用**：使用epoll/kqueue等机制处理并发连接
4. **事件驱动**：基于事件循环的异步处理模型

### 3.2 关键设计决策
- **数据结构实现**：
  - 使用Go原生数据结构（map、slice、双向链表）
  - 分片并发字典减少锁竞争
- **内存管理**：
  - 支持设置最大内存限制，防止OOM
  - 提供内存使用统计和碎片率监控
- **网络协议**：
  - RESP2协议
  - 支持管道（Pipeline）批量发送命令
- **TTL管理**：
  - 分层时间轮实现，10ms间隔，1024个桶
  - 惰性删除 + 主动删除相结合

---

## 4. 验收标准

### 4.1 功能验收
- [ ] 支持所有基础数据类型（String、List、Set、Hash、ZSet）
- [ ] 支持键的过期设置和自动淘汰
- [ ] 支持事务的原子性执行

### 4.2 可靠性验收
- [ ] 支持RDB和AOF两种持久化方式
- [ ] 支持主从复制和数据同步
- [ ] 进程崩溃后可从持久化文件恢复数据

### 4.3 性能验收
- [ ] 单实例QPS > 10万（SET/GET操作）
- [ ] P99响应时间 < 1毫秒
- [ ] 支持1万并发连接

### 4.4 稳定性验收
- [ ] 7x24小时稳定运行
- [ ] 内存使用可控（不超过maxmemory限制）

---

## 5. 附加说明

### 5.1 需求优先级
- **P0（必须有）**：基础数据类型、过期策略、持久化、主从复制
- **P1（重要）**：事务、AOF重写
- **P2（可选）**：哨兵高可用、集群模式

### 5.2 技术选型建议
- **编程语言**：Go（开发效率和性能平衡）
- **网络模型**：I/O多路复用（epoll/kqueue）
- **并发模型**：单线程事件循环 + 分片锁

### 5.3 演进路线
1. **第一阶段（已完成）**：实现基础的单机KV存储（String、Hash）
2. **第二阶段（已完成）**：完善数据类型（List、Set、ZSet）和过期机制
3. **第三阶段（已完成）**：增加事务功能和持久化机制
4. **第四阶段（已完成）**：实现主从复制
5. **第五阶段（待实现）**：实现哨兵高可用
6. **第六阶段（待实现）**：实现集群模式（水平扩展）

---

## 6. 总结

本需求文档从实际业务痛点出发，定义了一个高性能内存缓存系统的核心需求。该系统旨在解决：

1. **性能瓶颈**：通过内存存储和高效数据结构，提供微秒级响应
2. **业务多样性**：丰富的数据类型支持复杂业务场景
3. **分布式协作**：提供共享存储，支持分布式锁、会话共享等
4. **开发效率**：简化缓存管理，降低代码复杂度

通过实现上述需求，该系统将成为现代应用架构中不可或缺的基础设施。
